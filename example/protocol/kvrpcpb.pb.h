// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kvrpcpb.proto

#ifndef PROTOBUF_kvrpcpb_2eproto__INCLUDED
#define PROTOBUF_kvrpcpb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "metapb.pb.h"
#include "errorpb.pb.h"
// @@protoc_insertion_point(includes)

namespace kvrpcpb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kvrpcpb_2eproto();
void protobuf_AssignDesc_kvrpcpb_2eproto();
void protobuf_ShutdownFile_kvrpcpb_2eproto();

class LockInfo;
class KeyError;
class Context;
class CmdGetRequest;
class CmdGetResponse;
class CmdScanRequest;
class KvPair;
class CmdScanResponse;
class Mutation;
class CmdPrewriteRequest;
class CmdPrewriteResponse;
class CmdCommitRequest;
class CmdCommitResponse;
class CmdBatchRollbackRequest;
class CmdBatchRollbackResponse;
class CmdCleanupRequest;
class CmdCleanupResponse;
class CmdBatchGetRequest;
class CmdBatchGetResponse;
class CmdScanLockRequest;
class CmdScanLockResponse;
class CmdResolveLockRequest;
class CmdResolveLockResponse;
class CmdGCRequest;
class CmdGCResponse;
class CmdRawGetRequest;
class CmdRawGetResponse;
class CmdRawPutRequest;
class CmdRawPutResponse;
class CmdRawDeleteRequest;
class CmdRawDeleteResponse;
class Request;
class Response;

enum MessageType {
  CmdGet = 0,
  CmdScan = 1,
  CmdPrewrite = 2,
  CmdCommit = 3,
  CmdCleanup = 4,
  CmdBatchGet = 7,
  CmdBatchRollback = 8,
  CmdScanLock = 9,
  CmdResolveLock = 10,
  CmdGC = 11,
  CmdRawGet = 256,
  CmdRawPut = 257,
  CmdRawDelete = 258
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = CmdGet;
const MessageType MessageType_MAX = CmdRawDelete;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum Op {
  Put = 0,
  Del = 1,
  Lock = 2
};
bool Op_IsValid(int value);
const Op Op_MIN = Put;
const Op Op_MAX = Lock;
const int Op_ARRAYSIZE = Op_MAX + 1;

const ::google::protobuf::EnumDescriptor* Op_descriptor();
inline const ::std::string& Op_Name(Op value) {
  return ::google::protobuf::internal::NameOfEnum(
    Op_descriptor(), value);
}
inline bool Op_Parse(
    const ::std::string& name, Op* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Op>(
    Op_descriptor(), name, value);
}
// ===================================================================

class LockInfo : public ::google::protobuf::Message {
 public:
  LockInfo();
  virtual ~LockInfo();

  LockInfo(const LockInfo& from);

  inline LockInfo& operator=(const LockInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LockInfo& default_instance();

  void Swap(LockInfo* other);

  // implements Message ----------------------------------------------

  LockInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LockInfo& from);
  void MergeFrom(const LockInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes primary_lock = 1;
  inline bool has_primary_lock() const;
  inline void clear_primary_lock();
  static const int kPrimaryLockFieldNumber = 1;
  inline const ::std::string& primary_lock() const;
  inline void set_primary_lock(const ::std::string& value);
  inline void set_primary_lock(const char* value);
  inline void set_primary_lock(const void* value, size_t size);
  inline ::std::string* mutable_primary_lock();
  inline ::std::string* release_primary_lock();
  inline void set_allocated_primary_lock(::std::string* primary_lock);

  // optional uint64 lock_version = 2;
  inline bool has_lock_version() const;
  inline void clear_lock_version();
  static const int kLockVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 lock_version() const;
  inline void set_lock_version(::google::protobuf::uint64 value);

  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint64 lock_ttl = 4;
  inline bool has_lock_ttl() const;
  inline void clear_lock_ttl();
  static const int kLockTtlFieldNumber = 4;
  inline ::google::protobuf::uint64 lock_ttl() const;
  inline void set_lock_ttl(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.LockInfo)
 private:
  inline void set_has_primary_lock();
  inline void clear_has_primary_lock();
  inline void set_has_lock_version();
  inline void clear_has_lock_version();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_lock_ttl();
  inline void clear_has_lock_ttl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* primary_lock_;
  ::google::protobuf::uint64 lock_version_;
  ::std::string* key_;
  ::google::protobuf::uint64 lock_ttl_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static LockInfo* default_instance_;
};
// -------------------------------------------------------------------

class KeyError : public ::google::protobuf::Message {
 public:
  KeyError();
  virtual ~KeyError();

  KeyError(const KeyError& from);

  inline KeyError& operator=(const KeyError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyError& default_instance();

  void Swap(KeyError* other);

  // implements Message ----------------------------------------------

  KeyError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyError& from);
  void MergeFrom(const KeyError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.LockInfo locked = 1;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 1;
  inline const ::kvrpcpb::LockInfo& locked() const;
  inline ::kvrpcpb::LockInfo* mutable_locked();
  inline ::kvrpcpb::LockInfo* release_locked();
  inline void set_allocated_locked(::kvrpcpb::LockInfo* locked);

  // optional string retryable = 2;
  inline bool has_retryable() const;
  inline void clear_retryable();
  static const int kRetryableFieldNumber = 2;
  inline const ::std::string& retryable() const;
  inline void set_retryable(const ::std::string& value);
  inline void set_retryable(const char* value);
  inline void set_retryable(const char* value, size_t size);
  inline ::std::string* mutable_retryable();
  inline ::std::string* release_retryable();
  inline void set_allocated_retryable(::std::string* retryable);

  // optional string abort = 3;
  inline bool has_abort() const;
  inline void clear_abort();
  static const int kAbortFieldNumber = 3;
  inline const ::std::string& abort() const;
  inline void set_abort(const ::std::string& value);
  inline void set_abort(const char* value);
  inline void set_abort(const char* value, size_t size);
  inline ::std::string* mutable_abort();
  inline ::std::string* release_abort();
  inline void set_allocated_abort(::std::string* abort);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KeyError)
 private:
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_retryable();
  inline void clear_has_retryable();
  inline void set_has_abort();
  inline void clear_has_abort();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::LockInfo* locked_;
  ::std::string* retryable_;
  ::std::string* abort_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static KeyError* default_instance_;
};
// -------------------------------------------------------------------

class Context : public ::google::protobuf::Message {
 public:
  Context();
  virtual ~Context();

  Context(const Context& from);

  inline Context& operator=(const Context& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Context& default_instance();

  void Swap(Context* other);

  // implements Message ----------------------------------------------

  Context* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Context& from);
  void MergeFrom(const Context& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 region_id = 1;
  inline bool has_region_id() const;
  inline void clear_region_id();
  static const int kRegionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 region_id() const;
  inline void set_region_id(::google::protobuf::uint64 value);

  // optional .metapb.RegionEpoch region_epoch = 2;
  inline bool has_region_epoch() const;
  inline void clear_region_epoch();
  static const int kRegionEpochFieldNumber = 2;
  inline const ::metapb::RegionEpoch& region_epoch() const;
  inline ::metapb::RegionEpoch* mutable_region_epoch();
  inline ::metapb::RegionEpoch* release_region_epoch();
  inline void set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch);

  // optional .metapb.Peer peer = 3;
  inline bool has_peer() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 3;
  inline const ::metapb::Peer& peer() const;
  inline ::metapb::Peer* mutable_peer();
  inline ::metapb::Peer* release_peer();
  inline void set_allocated_peer(::metapb::Peer* peer);

  // optional bool read_quorum = 4;
  inline bool has_read_quorum() const;
  inline void clear_read_quorum();
  static const int kReadQuorumFieldNumber = 4;
  inline bool read_quorum() const;
  inline void set_read_quorum(bool value);

  // optional uint64 term = 5;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 5;
  inline ::google::protobuf::uint64 term() const;
  inline void set_term(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Context)
 private:
  inline void set_has_region_id();
  inline void clear_has_region_id();
  inline void set_has_region_epoch();
  inline void clear_has_region_epoch();
  inline void set_has_peer();
  inline void clear_has_peer();
  inline void set_has_read_quorum();
  inline void clear_has_read_quorum();
  inline void set_has_term();
  inline void clear_has_term();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 region_id_;
  ::metapb::RegionEpoch* region_epoch_;
  ::metapb::Peer* peer_;
  ::google::protobuf::uint64 term_;
  bool read_quorum_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static Context* default_instance_;
};
// -------------------------------------------------------------------

class CmdGetRequest : public ::google::protobuf::Message {
 public:
  CmdGetRequest();
  virtual ~CmdGetRequest();

  CmdGetRequest(const CmdGetRequest& from);

  inline CmdGetRequest& operator=(const CmdGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdGetRequest& default_instance();

  void Swap(CmdGetRequest* other);

  // implements Message ----------------------------------------------

  CmdGetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdGetRequest& from);
  void MergeFrom(const CmdGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint64 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdGetRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::google::protobuf::uint64 version_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdGetResponse : public ::google::protobuf::Message {
 public:
  CmdGetResponse();
  virtual ~CmdGetResponse();

  CmdGetResponse(const CmdGetResponse& from);

  inline CmdGetResponse& operator=(const CmdGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdGetResponse& default_instance();

  void Swap(CmdGetResponse* other);

  // implements Message ----------------------------------------------

  CmdGetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdGetResponse& from);
  void MergeFrom(const CmdGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdGetResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdScanRequest : public ::google::protobuf::Message {
 public:
  CmdScanRequest();
  virtual ~CmdScanRequest();

  CmdScanRequest(const CmdScanRequest& from);

  inline CmdScanRequest& operator=(const CmdScanRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdScanRequest& default_instance();

  void Swap(CmdScanRequest* other);

  // implements Message ----------------------------------------------

  CmdScanRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdScanRequest& from);
  void MergeFrom(const CmdScanRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes start_key = 1;
  inline bool has_start_key() const;
  inline void clear_start_key();
  static const int kStartKeyFieldNumber = 1;
  inline const ::std::string& start_key() const;
  inline void set_start_key(const ::std::string& value);
  inline void set_start_key(const char* value);
  inline void set_start_key(const void* value, size_t size);
  inline ::std::string* mutable_start_key();
  inline ::std::string* release_start_key();
  inline void set_allocated_start_key(::std::string* start_key);

  // optional uint32 limit = 2;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 2;
  inline ::google::protobuf::uint32 limit() const;
  inline void set_limit(::google::protobuf::uint32 value);

  // optional uint64 version = 3;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 3;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // optional bool key_only = 4;
  inline bool has_key_only() const;
  inline void clear_key_only();
  static const int kKeyOnlyFieldNumber = 4;
  inline bool key_only() const;
  inline void set_key_only(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdScanRequest)
 private:
  inline void set_has_start_key();
  inline void clear_has_start_key();
  inline void set_has_limit();
  inline void clear_has_limit();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_key_only();
  inline void clear_has_key_only();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* start_key_;
  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint32 limit_;
  bool key_only_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdScanRequest* default_instance_;
};
// -------------------------------------------------------------------

class KvPair : public ::google::protobuf::Message {
 public:
  KvPair();
  virtual ~KvPair();

  KvPair(const KvPair& from);

  inline KvPair& operator=(const KvPair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KvPair& default_instance();

  void Swap(KvPair* other);

  // implements Message ----------------------------------------------

  KvPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KvPair& from);
  void MergeFrom(const KvPair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.KvPair)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static KvPair* default_instance_;
};
// -------------------------------------------------------------------

class CmdScanResponse : public ::google::protobuf::Message {
 public:
  CmdScanResponse();
  virtual ~CmdScanResponse();

  CmdScanResponse(const CmdScanResponse& from);

  inline CmdScanResponse& operator=(const CmdScanResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdScanResponse& default_instance();

  void Swap(CmdScanResponse* other);

  // implements Message ----------------------------------------------

  CmdScanResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdScanResponse& from);
  void MergeFrom(const CmdScanResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair pairs = 1;
  inline int pairs_size() const;
  inline void clear_pairs();
  static const int kPairsFieldNumber = 1;
  inline const ::kvrpcpb::KvPair& pairs(int index) const;
  inline ::kvrpcpb::KvPair* mutable_pairs(int index);
  inline ::kvrpcpb::KvPair* add_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_pairs();

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdScanResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > pairs_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdScanResponse* default_instance_;
};
// -------------------------------------------------------------------

class Mutation : public ::google::protobuf::Message {
 public:
  Mutation();
  virtual ~Mutation();

  Mutation(const Mutation& from);

  inline Mutation& operator=(const Mutation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mutation& default_instance();

  void Swap(Mutation* other);

  // implements Message ----------------------------------------------

  Mutation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mutation& from);
  void MergeFrom(const Mutation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.Op op = 1;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 1;
  inline ::kvrpcpb::Op op() const;
  inline void set_op(::kvrpcpb::Op value);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Mutation)
 private:
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  int op_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static Mutation* default_instance_;
};
// -------------------------------------------------------------------

class CmdPrewriteRequest : public ::google::protobuf::Message {
 public:
  CmdPrewriteRequest();
  virtual ~CmdPrewriteRequest();

  CmdPrewriteRequest(const CmdPrewriteRequest& from);

  inline CmdPrewriteRequest& operator=(const CmdPrewriteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdPrewriteRequest& default_instance();

  void Swap(CmdPrewriteRequest* other);

  // implements Message ----------------------------------------------

  CmdPrewriteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdPrewriteRequest& from);
  void MergeFrom(const CmdPrewriteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.Mutation mutations = 1;
  inline int mutations_size() const;
  inline void clear_mutations();
  static const int kMutationsFieldNumber = 1;
  inline const ::kvrpcpb::Mutation& mutations(int index) const;
  inline ::kvrpcpb::Mutation* mutable_mutations(int index);
  inline ::kvrpcpb::Mutation* add_mutations();
  inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >&
      mutations() const;
  inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >*
      mutable_mutations();

  // optional bytes primary_lock = 2;
  inline bool has_primary_lock() const;
  inline void clear_primary_lock();
  static const int kPrimaryLockFieldNumber = 2;
  inline const ::std::string& primary_lock() const;
  inline void set_primary_lock(const ::std::string& value);
  inline void set_primary_lock(const char* value);
  inline void set_primary_lock(const void* value, size_t size);
  inline ::std::string* mutable_primary_lock();
  inline ::std::string* release_primary_lock();
  inline void set_allocated_primary_lock(::std::string* primary_lock);

  // optional uint64 start_version = 3;
  inline bool has_start_version() const;
  inline void clear_start_version();
  static const int kStartVersionFieldNumber = 3;
  inline ::google::protobuf::uint64 start_version() const;
  inline void set_start_version(::google::protobuf::uint64 value);

  // optional uint64 lock_ttl = 4;
  inline bool has_lock_ttl() const;
  inline void clear_lock_ttl();
  static const int kLockTtlFieldNumber = 4;
  inline ::google::protobuf::uint64 lock_ttl() const;
  inline void set_lock_ttl(::google::protobuf::uint64 value);

  // optional bool skip_constraint_check = 5;
  inline bool has_skip_constraint_check() const;
  inline void clear_skip_constraint_check();
  static const int kSkipConstraintCheckFieldNumber = 5;
  inline bool skip_constraint_check() const;
  inline void set_skip_constraint_check(bool value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdPrewriteRequest)
 private:
  inline void set_has_primary_lock();
  inline void clear_has_primary_lock();
  inline void set_has_start_version();
  inline void clear_has_start_version();
  inline void set_has_lock_ttl();
  inline void clear_has_lock_ttl();
  inline void set_has_skip_constraint_check();
  inline void clear_has_skip_constraint_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation > mutations_;
  ::std::string* primary_lock_;
  ::google::protobuf::uint64 start_version_;
  ::google::protobuf::uint64 lock_ttl_;
  bool skip_constraint_check_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdPrewriteRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdPrewriteResponse : public ::google::protobuf::Message {
 public:
  CmdPrewriteResponse();
  virtual ~CmdPrewriteResponse();

  CmdPrewriteResponse(const CmdPrewriteResponse& from);

  inline CmdPrewriteResponse& operator=(const CmdPrewriteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdPrewriteResponse& default_instance();

  void Swap(CmdPrewriteResponse* other);

  // implements Message ----------------------------------------------

  CmdPrewriteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdPrewriteResponse& from);
  void MergeFrom(const CmdPrewriteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KeyError errors = 1;
  inline int errors_size() const;
  inline void clear_errors();
  static const int kErrorsFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& errors(int index) const;
  inline ::kvrpcpb::KeyError* mutable_errors(int index);
  inline ::kvrpcpb::KeyError* add_errors();
  inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >&
      errors() const;
  inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >*
      mutable_errors();

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdPrewriteResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError > errors_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdPrewriteResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdCommitRequest : public ::google::protobuf::Message {
 public:
  CmdCommitRequest();
  virtual ~CmdCommitRequest();

  CmdCommitRequest(const CmdCommitRequest& from);

  inline CmdCommitRequest& operator=(const CmdCommitRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdCommitRequest& default_instance();

  void Swap(CmdCommitRequest* other);

  // implements Message ----------------------------------------------

  CmdCommitRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdCommitRequest& from);
  void MergeFrom(const CmdCommitRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 start_version = 1;
  inline bool has_start_version() const;
  inline void clear_start_version();
  static const int kStartVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 start_version() const;
  inline void set_start_version(::google::protobuf::uint64 value);

  // repeated bytes keys = 2;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 2;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional uint64 commit_version = 3;
  inline bool has_commit_version() const;
  inline void clear_commit_version();
  static const int kCommitVersionFieldNumber = 3;
  inline ::google::protobuf::uint64 commit_version() const;
  inline void set_commit_version(::google::protobuf::uint64 value);

  // optional bytes binlog = 4;
  inline bool has_binlog() const;
  inline void clear_binlog();
  static const int kBinlogFieldNumber = 4;
  inline const ::std::string& binlog() const;
  inline void set_binlog(const ::std::string& value);
  inline void set_binlog(const char* value);
  inline void set_binlog(const void* value, size_t size);
  inline ::std::string* mutable_binlog();
  inline ::std::string* release_binlog();
  inline void set_allocated_binlog(::std::string* binlog);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdCommitRequest)
 private:
  inline void set_has_start_version();
  inline void clear_has_start_version();
  inline void set_has_commit_version();
  inline void clear_has_commit_version();
  inline void set_has_binlog();
  inline void clear_has_binlog();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 start_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::uint64 commit_version_;
  ::std::string* binlog_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdCommitRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdCommitResponse : public ::google::protobuf::Message {
 public:
  CmdCommitResponse();
  virtual ~CmdCommitResponse();

  CmdCommitResponse(const CmdCommitResponse& from);

  inline CmdCommitResponse& operator=(const CmdCommitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdCommitResponse& default_instance();

  void Swap(CmdCommitResponse* other);

  // implements Message ----------------------------------------------

  CmdCommitResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdCommitResponse& from);
  void MergeFrom(const CmdCommitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdCommitResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdCommitResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdBatchRollbackRequest : public ::google::protobuf::Message {
 public:
  CmdBatchRollbackRequest();
  virtual ~CmdBatchRollbackRequest();

  CmdBatchRollbackRequest(const CmdBatchRollbackRequest& from);

  inline CmdBatchRollbackRequest& operator=(const CmdBatchRollbackRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdBatchRollbackRequest& default_instance();

  void Swap(CmdBatchRollbackRequest* other);

  // implements Message ----------------------------------------------

  CmdBatchRollbackRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdBatchRollbackRequest& from);
  void MergeFrom(const CmdBatchRollbackRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 start_version = 1;
  inline bool has_start_version() const;
  inline void clear_start_version();
  static const int kStartVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 start_version() const;
  inline void set_start_version(::google::protobuf::uint64 value);

  // repeated bytes keys = 2;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 2;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdBatchRollbackRequest)
 private:
  inline void set_has_start_version();
  inline void clear_has_start_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 start_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdBatchRollbackRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdBatchRollbackResponse : public ::google::protobuf::Message {
 public:
  CmdBatchRollbackResponse();
  virtual ~CmdBatchRollbackResponse();

  CmdBatchRollbackResponse(const CmdBatchRollbackResponse& from);

  inline CmdBatchRollbackResponse& operator=(const CmdBatchRollbackResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdBatchRollbackResponse& default_instance();

  void Swap(CmdBatchRollbackResponse* other);

  // implements Message ----------------------------------------------

  CmdBatchRollbackResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdBatchRollbackResponse& from);
  void MergeFrom(const CmdBatchRollbackResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdBatchRollbackResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdBatchRollbackResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdCleanupRequest : public ::google::protobuf::Message {
 public:
  CmdCleanupRequest();
  virtual ~CmdCleanupRequest();

  CmdCleanupRequest(const CmdCleanupRequest& from);

  inline CmdCleanupRequest& operator=(const CmdCleanupRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdCleanupRequest& default_instance();

  void Swap(CmdCleanupRequest* other);

  // implements Message ----------------------------------------------

  CmdCleanupRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdCleanupRequest& from);
  void MergeFrom(const CmdCleanupRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional uint64 start_version = 2;
  inline bool has_start_version() const;
  inline void clear_start_version();
  static const int kStartVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 start_version() const;
  inline void set_start_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdCleanupRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_start_version();
  inline void clear_has_start_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::google::protobuf::uint64 start_version_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdCleanupRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdCleanupResponse : public ::google::protobuf::Message {
 public:
  CmdCleanupResponse();
  virtual ~CmdCleanupResponse();

  CmdCleanupResponse(const CmdCleanupResponse& from);

  inline CmdCleanupResponse& operator=(const CmdCleanupResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdCleanupResponse& default_instance();

  void Swap(CmdCleanupResponse* other);

  // implements Message ----------------------------------------------

  CmdCleanupResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdCleanupResponse& from);
  void MergeFrom(const CmdCleanupResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // optional uint64 commit_version = 2;
  inline bool has_commit_version() const;
  inline void clear_commit_version();
  static const int kCommitVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 commit_version() const;
  inline void set_commit_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdCleanupResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_commit_version();
  inline void clear_has_commit_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  ::google::protobuf::uint64 commit_version_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdCleanupResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdBatchGetRequest : public ::google::protobuf::Message {
 public:
  CmdBatchGetRequest();
  virtual ~CmdBatchGetRequest();

  CmdBatchGetRequest(const CmdBatchGetRequest& from);

  inline CmdBatchGetRequest& operator=(const CmdBatchGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdBatchGetRequest& default_instance();

  void Swap(CmdBatchGetRequest* other);

  // implements Message ----------------------------------------------

  CmdBatchGetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdBatchGetRequest& from);
  void MergeFrom(const CmdBatchGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes keys = 1;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 1;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional uint64 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdBatchGetRequest)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::uint64 version_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdBatchGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdBatchGetResponse : public ::google::protobuf::Message {
 public:
  CmdBatchGetResponse();
  virtual ~CmdBatchGetResponse();

  CmdBatchGetResponse(const CmdBatchGetResponse& from);

  inline CmdBatchGetResponse& operator=(const CmdBatchGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdBatchGetResponse& default_instance();

  void Swap(CmdBatchGetResponse* other);

  // implements Message ----------------------------------------------

  CmdBatchGetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdBatchGetResponse& from);
  void MergeFrom(const CmdBatchGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .kvrpcpb.KvPair pairs = 1;
  inline int pairs_size() const;
  inline void clear_pairs();
  static const int kPairsFieldNumber = 1;
  inline const ::kvrpcpb::KvPair& pairs(int index) const;
  inline ::kvrpcpb::KvPair* mutable_pairs(int index);
  inline ::kvrpcpb::KvPair* add_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
      pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
      mutable_pairs();

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdBatchGetResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair > pairs_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdBatchGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdScanLockRequest : public ::google::protobuf::Message {
 public:
  CmdScanLockRequest();
  virtual ~CmdScanLockRequest();

  CmdScanLockRequest(const CmdScanLockRequest& from);

  inline CmdScanLockRequest& operator=(const CmdScanLockRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdScanLockRequest& default_instance();

  void Swap(CmdScanLockRequest* other);

  // implements Message ----------------------------------------------

  CmdScanLockRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdScanLockRequest& from);
  void MergeFrom(const CmdScanLockRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 max_version = 1;
  inline bool has_max_version() const;
  inline void clear_max_version();
  static const int kMaxVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 max_version() const;
  inline void set_max_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdScanLockRequest)
 private:
  inline void set_has_max_version();
  inline void clear_has_max_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 max_version_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdScanLockRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdScanLockResponse : public ::google::protobuf::Message {
 public:
  CmdScanLockResponse();
  virtual ~CmdScanLockResponse();

  CmdScanLockResponse(const CmdScanLockResponse& from);

  inline CmdScanLockResponse& operator=(const CmdScanLockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdScanLockResponse& default_instance();

  void Swap(CmdScanLockResponse* other);

  // implements Message ----------------------------------------------

  CmdScanLockResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdScanLockResponse& from);
  void MergeFrom(const CmdScanLockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // repeated .kvrpcpb.LockInfo locks = 2;
  inline int locks_size() const;
  inline void clear_locks();
  static const int kLocksFieldNumber = 2;
  inline const ::kvrpcpb::LockInfo& locks(int index) const;
  inline ::kvrpcpb::LockInfo* mutable_locks(int index);
  inline ::kvrpcpb::LockInfo* add_locks();
  inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
      locks() const;
  inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
      mutable_locks();

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdScanLockResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo > locks_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdScanLockResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdResolveLockRequest : public ::google::protobuf::Message {
 public:
  CmdResolveLockRequest();
  virtual ~CmdResolveLockRequest();

  CmdResolveLockRequest(const CmdResolveLockRequest& from);

  inline CmdResolveLockRequest& operator=(const CmdResolveLockRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdResolveLockRequest& default_instance();

  void Swap(CmdResolveLockRequest* other);

  // implements Message ----------------------------------------------

  CmdResolveLockRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdResolveLockRequest& from);
  void MergeFrom(const CmdResolveLockRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 start_version = 1;
  inline bool has_start_version() const;
  inline void clear_start_version();
  static const int kStartVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 start_version() const;
  inline void set_start_version(::google::protobuf::uint64 value);

  // optional uint64 commit_version = 2;
  inline bool has_commit_version() const;
  inline void clear_commit_version();
  static const int kCommitVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 commit_version() const;
  inline void set_commit_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdResolveLockRequest)
 private:
  inline void set_has_start_version();
  inline void clear_has_start_version();
  inline void set_has_commit_version();
  inline void clear_has_commit_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 start_version_;
  ::google::protobuf::uint64 commit_version_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdResolveLockRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdResolveLockResponse : public ::google::protobuf::Message {
 public:
  CmdResolveLockResponse();
  virtual ~CmdResolveLockResponse();

  CmdResolveLockResponse(const CmdResolveLockResponse& from);

  inline CmdResolveLockResponse& operator=(const CmdResolveLockResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdResolveLockResponse& default_instance();

  void Swap(CmdResolveLockResponse* other);

  // implements Message ----------------------------------------------

  CmdResolveLockResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdResolveLockResponse& from);
  void MergeFrom(const CmdResolveLockResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdResolveLockResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdResolveLockResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdGCRequest : public ::google::protobuf::Message {
 public:
  CmdGCRequest();
  virtual ~CmdGCRequest();

  CmdGCRequest(const CmdGCRequest& from);

  inline CmdGCRequest& operator=(const CmdGCRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdGCRequest& default_instance();

  void Swap(CmdGCRequest* other);

  // implements Message ----------------------------------------------

  CmdGCRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdGCRequest& from);
  void MergeFrom(const CmdGCRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 safe_point = 1;
  inline bool has_safe_point() const;
  inline void clear_safe_point();
  static const int kSafePointFieldNumber = 1;
  inline ::google::protobuf::uint64 safe_point() const;
  inline void set_safe_point(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdGCRequest)
 private:
  inline void set_has_safe_point();
  inline void clear_has_safe_point();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 safe_point_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdGCRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdGCResponse : public ::google::protobuf::Message {
 public:
  CmdGCResponse();
  virtual ~CmdGCResponse();

  CmdGCResponse(const CmdGCResponse& from);

  inline CmdGCResponse& operator=(const CmdGCResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdGCResponse& default_instance();

  void Swap(CmdGCResponse* other);

  // implements Message ----------------------------------------------

  CmdGCResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdGCResponse& from);
  void MergeFrom(const CmdGCResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.KeyError error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::kvrpcpb::KeyError& error() const;
  inline ::kvrpcpb::KeyError* mutable_error();
  inline ::kvrpcpb::KeyError* release_error();
  inline void set_allocated_error(::kvrpcpb::KeyError* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdGCResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::KeyError* error_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdGCResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdRawGetRequest : public ::google::protobuf::Message {
 public:
  CmdRawGetRequest();
  virtual ~CmdRawGetRequest();

  CmdRawGetRequest(const CmdRawGetRequest& from);

  inline CmdRawGetRequest& operator=(const CmdRawGetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdRawGetRequest& default_instance();

  void Swap(CmdRawGetRequest* other);

  // implements Message ----------------------------------------------

  CmdRawGetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdRawGetRequest& from);
  void MergeFrom(const CmdRawGetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdRawGetRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdRawGetRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdRawGetResponse : public ::google::protobuf::Message {
 public:
  CmdRawGetResponse();
  virtual ~CmdRawGetResponse();

  CmdRawGetResponse(const CmdRawGetResponse& from);

  inline CmdRawGetResponse& operator=(const CmdRawGetResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdRawGetResponse& default_instance();

  void Swap(CmdRawGetResponse* other);

  // implements Message ----------------------------------------------

  CmdRawGetResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdRawGetResponse& from);
  void MergeFrom(const CmdRawGetResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdRawGetResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdRawGetResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdRawPutRequest : public ::google::protobuf::Message {
 public:
  CmdRawPutRequest();
  virtual ~CmdRawPutRequest();

  CmdRawPutRequest(const CmdRawPutRequest& from);

  inline CmdRawPutRequest& operator=(const CmdRawPutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdRawPutRequest& default_instance();

  void Swap(CmdRawPutRequest* other);

  // implements Message ----------------------------------------------

  CmdRawPutRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdRawPutRequest& from);
  void MergeFrom(const CmdRawPutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdRawPutRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdRawPutRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdRawPutResponse : public ::google::protobuf::Message {
 public:
  CmdRawPutResponse();
  virtual ~CmdRawPutResponse();

  CmdRawPutResponse(const CmdRawPutResponse& from);

  inline CmdRawPutResponse& operator=(const CmdRawPutResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdRawPutResponse& default_instance();

  void Swap(CmdRawPutResponse* other);

  // implements Message ----------------------------------------------

  CmdRawPutResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdRawPutResponse& from);
  void MergeFrom(const CmdRawPutResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdRawPutResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdRawPutResponse* default_instance_;
};
// -------------------------------------------------------------------

class CmdRawDeleteRequest : public ::google::protobuf::Message {
 public:
  CmdRawDeleteRequest();
  virtual ~CmdRawDeleteRequest();

  CmdRawDeleteRequest(const CmdRawDeleteRequest& from);

  inline CmdRawDeleteRequest& operator=(const CmdRawDeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdRawDeleteRequest& default_instance();

  void Swap(CmdRawDeleteRequest* other);

  // implements Message ----------------------------------------------

  CmdRawDeleteRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdRawDeleteRequest& from);
  void MergeFrom(const CmdRawDeleteRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdRawDeleteRequest)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdRawDeleteRequest* default_instance_;
};
// -------------------------------------------------------------------

class CmdRawDeleteResponse : public ::google::protobuf::Message {
 public:
  CmdRawDeleteResponse();
  virtual ~CmdRawDeleteResponse();

  CmdRawDeleteResponse(const CmdRawDeleteResponse& from);

  inline CmdRawDeleteResponse& operator=(const CmdRawDeleteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CmdRawDeleteResponse& default_instance();

  void Swap(CmdRawDeleteResponse* other);

  // implements Message ----------------------------------------------

  CmdRawDeleteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CmdRawDeleteResponse& from);
  void MergeFrom(const CmdRawDeleteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:kvrpcpb.CmdRawDeleteResponse)
 private:
  inline void set_has_error();
  inline void clear_has_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* error_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static CmdRawDeleteResponse* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::kvrpcpb::MessageType type() const;
  inline void set_type(::kvrpcpb::MessageType value);

  // optional .kvrpcpb.Context context = 2;
  inline bool has_context() const;
  inline void clear_context();
  static const int kContextFieldNumber = 2;
  inline const ::kvrpcpb::Context& context() const;
  inline ::kvrpcpb::Context* mutable_context();
  inline ::kvrpcpb::Context* release_context();
  inline void set_allocated_context(::kvrpcpb::Context* context);

  // optional .kvrpcpb.CmdGetRequest cmd_get_req = 3;
  inline bool has_cmd_get_req() const;
  inline void clear_cmd_get_req();
  static const int kCmdGetReqFieldNumber = 3;
  inline const ::kvrpcpb::CmdGetRequest& cmd_get_req() const;
  inline ::kvrpcpb::CmdGetRequest* mutable_cmd_get_req();
  inline ::kvrpcpb::CmdGetRequest* release_cmd_get_req();
  inline void set_allocated_cmd_get_req(::kvrpcpb::CmdGetRequest* cmd_get_req);

  // optional .kvrpcpb.CmdScanRequest cmd_scan_req = 4;
  inline bool has_cmd_scan_req() const;
  inline void clear_cmd_scan_req();
  static const int kCmdScanReqFieldNumber = 4;
  inline const ::kvrpcpb::CmdScanRequest& cmd_scan_req() const;
  inline ::kvrpcpb::CmdScanRequest* mutable_cmd_scan_req();
  inline ::kvrpcpb::CmdScanRequest* release_cmd_scan_req();
  inline void set_allocated_cmd_scan_req(::kvrpcpb::CmdScanRequest* cmd_scan_req);

  // optional .kvrpcpb.CmdPrewriteRequest cmd_prewrite_req = 5;
  inline bool has_cmd_prewrite_req() const;
  inline void clear_cmd_prewrite_req();
  static const int kCmdPrewriteReqFieldNumber = 5;
  inline const ::kvrpcpb::CmdPrewriteRequest& cmd_prewrite_req() const;
  inline ::kvrpcpb::CmdPrewriteRequest* mutable_cmd_prewrite_req();
  inline ::kvrpcpb::CmdPrewriteRequest* release_cmd_prewrite_req();
  inline void set_allocated_cmd_prewrite_req(::kvrpcpb::CmdPrewriteRequest* cmd_prewrite_req);

  // optional .kvrpcpb.CmdCommitRequest cmd_commit_req = 6;
  inline bool has_cmd_commit_req() const;
  inline void clear_cmd_commit_req();
  static const int kCmdCommitReqFieldNumber = 6;
  inline const ::kvrpcpb::CmdCommitRequest& cmd_commit_req() const;
  inline ::kvrpcpb::CmdCommitRequest* mutable_cmd_commit_req();
  inline ::kvrpcpb::CmdCommitRequest* release_cmd_commit_req();
  inline void set_allocated_cmd_commit_req(::kvrpcpb::CmdCommitRequest* cmd_commit_req);

  // optional .kvrpcpb.CmdCleanupRequest cmd_cleanup_req = 7;
  inline bool has_cmd_cleanup_req() const;
  inline void clear_cmd_cleanup_req();
  static const int kCmdCleanupReqFieldNumber = 7;
  inline const ::kvrpcpb::CmdCleanupRequest& cmd_cleanup_req() const;
  inline ::kvrpcpb::CmdCleanupRequest* mutable_cmd_cleanup_req();
  inline ::kvrpcpb::CmdCleanupRequest* release_cmd_cleanup_req();
  inline void set_allocated_cmd_cleanup_req(::kvrpcpb::CmdCleanupRequest* cmd_cleanup_req);

  // optional .kvrpcpb.CmdBatchGetRequest cmd_batch_get_req = 10;
  inline bool has_cmd_batch_get_req() const;
  inline void clear_cmd_batch_get_req();
  static const int kCmdBatchGetReqFieldNumber = 10;
  inline const ::kvrpcpb::CmdBatchGetRequest& cmd_batch_get_req() const;
  inline ::kvrpcpb::CmdBatchGetRequest* mutable_cmd_batch_get_req();
  inline ::kvrpcpb::CmdBatchGetRequest* release_cmd_batch_get_req();
  inline void set_allocated_cmd_batch_get_req(::kvrpcpb::CmdBatchGetRequest* cmd_batch_get_req);

  // optional .kvrpcpb.CmdBatchRollbackRequest cmd_batch_rollback_req = 11;
  inline bool has_cmd_batch_rollback_req() const;
  inline void clear_cmd_batch_rollback_req();
  static const int kCmdBatchRollbackReqFieldNumber = 11;
  inline const ::kvrpcpb::CmdBatchRollbackRequest& cmd_batch_rollback_req() const;
  inline ::kvrpcpb::CmdBatchRollbackRequest* mutable_cmd_batch_rollback_req();
  inline ::kvrpcpb::CmdBatchRollbackRequest* release_cmd_batch_rollback_req();
  inline void set_allocated_cmd_batch_rollback_req(::kvrpcpb::CmdBatchRollbackRequest* cmd_batch_rollback_req);

  // optional .kvrpcpb.CmdScanLockRequest cmd_scan_lock_req = 12;
  inline bool has_cmd_scan_lock_req() const;
  inline void clear_cmd_scan_lock_req();
  static const int kCmdScanLockReqFieldNumber = 12;
  inline const ::kvrpcpb::CmdScanLockRequest& cmd_scan_lock_req() const;
  inline ::kvrpcpb::CmdScanLockRequest* mutable_cmd_scan_lock_req();
  inline ::kvrpcpb::CmdScanLockRequest* release_cmd_scan_lock_req();
  inline void set_allocated_cmd_scan_lock_req(::kvrpcpb::CmdScanLockRequest* cmd_scan_lock_req);

  // optional .kvrpcpb.CmdResolveLockRequest cmd_resolve_lock_req = 13;
  inline bool has_cmd_resolve_lock_req() const;
  inline void clear_cmd_resolve_lock_req();
  static const int kCmdResolveLockReqFieldNumber = 13;
  inline const ::kvrpcpb::CmdResolveLockRequest& cmd_resolve_lock_req() const;
  inline ::kvrpcpb::CmdResolveLockRequest* mutable_cmd_resolve_lock_req();
  inline ::kvrpcpb::CmdResolveLockRequest* release_cmd_resolve_lock_req();
  inline void set_allocated_cmd_resolve_lock_req(::kvrpcpb::CmdResolveLockRequest* cmd_resolve_lock_req);

  // optional .kvrpcpb.CmdGCRequest cmd_gc_req = 14;
  inline bool has_cmd_gc_req() const;
  inline void clear_cmd_gc_req();
  static const int kCmdGcReqFieldNumber = 14;
  inline const ::kvrpcpb::CmdGCRequest& cmd_gc_req() const;
  inline ::kvrpcpb::CmdGCRequest* mutable_cmd_gc_req();
  inline ::kvrpcpb::CmdGCRequest* release_cmd_gc_req();
  inline void set_allocated_cmd_gc_req(::kvrpcpb::CmdGCRequest* cmd_gc_req);

  // optional .kvrpcpb.CmdRawGetRequest cmd_raw_get_req = 256;
  inline bool has_cmd_raw_get_req() const;
  inline void clear_cmd_raw_get_req();
  static const int kCmdRawGetReqFieldNumber = 256;
  inline const ::kvrpcpb::CmdRawGetRequest& cmd_raw_get_req() const;
  inline ::kvrpcpb::CmdRawGetRequest* mutable_cmd_raw_get_req();
  inline ::kvrpcpb::CmdRawGetRequest* release_cmd_raw_get_req();
  inline void set_allocated_cmd_raw_get_req(::kvrpcpb::CmdRawGetRequest* cmd_raw_get_req);

  // optional .kvrpcpb.CmdRawPutRequest cmd_raw_put_req = 257;
  inline bool has_cmd_raw_put_req() const;
  inline void clear_cmd_raw_put_req();
  static const int kCmdRawPutReqFieldNumber = 257;
  inline const ::kvrpcpb::CmdRawPutRequest& cmd_raw_put_req() const;
  inline ::kvrpcpb::CmdRawPutRequest* mutable_cmd_raw_put_req();
  inline ::kvrpcpb::CmdRawPutRequest* release_cmd_raw_put_req();
  inline void set_allocated_cmd_raw_put_req(::kvrpcpb::CmdRawPutRequest* cmd_raw_put_req);

  // optional .kvrpcpb.CmdRawDeleteRequest cmd_raw_delete_req = 258;
  inline bool has_cmd_raw_delete_req() const;
  inline void clear_cmd_raw_delete_req();
  static const int kCmdRawDeleteReqFieldNumber = 258;
  inline const ::kvrpcpb::CmdRawDeleteRequest& cmd_raw_delete_req() const;
  inline ::kvrpcpb::CmdRawDeleteRequest* mutable_cmd_raw_delete_req();
  inline ::kvrpcpb::CmdRawDeleteRequest* release_cmd_raw_delete_req();
  inline void set_allocated_cmd_raw_delete_req(::kvrpcpb::CmdRawDeleteRequest* cmd_raw_delete_req);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Request)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_context();
  inline void clear_has_context();
  inline void set_has_cmd_get_req();
  inline void clear_has_cmd_get_req();
  inline void set_has_cmd_scan_req();
  inline void clear_has_cmd_scan_req();
  inline void set_has_cmd_prewrite_req();
  inline void clear_has_cmd_prewrite_req();
  inline void set_has_cmd_commit_req();
  inline void clear_has_cmd_commit_req();
  inline void set_has_cmd_cleanup_req();
  inline void clear_has_cmd_cleanup_req();
  inline void set_has_cmd_batch_get_req();
  inline void clear_has_cmd_batch_get_req();
  inline void set_has_cmd_batch_rollback_req();
  inline void clear_has_cmd_batch_rollback_req();
  inline void set_has_cmd_scan_lock_req();
  inline void clear_has_cmd_scan_lock_req();
  inline void set_has_cmd_resolve_lock_req();
  inline void clear_has_cmd_resolve_lock_req();
  inline void set_has_cmd_gc_req();
  inline void clear_has_cmd_gc_req();
  inline void set_has_cmd_raw_get_req();
  inline void clear_has_cmd_raw_get_req();
  inline void set_has_cmd_raw_put_req();
  inline void clear_has_cmd_raw_put_req();
  inline void set_has_cmd_raw_delete_req();
  inline void clear_has_cmd_raw_delete_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::kvrpcpb::Context* context_;
  ::kvrpcpb::CmdGetRequest* cmd_get_req_;
  ::kvrpcpb::CmdScanRequest* cmd_scan_req_;
  ::kvrpcpb::CmdPrewriteRequest* cmd_prewrite_req_;
  ::kvrpcpb::CmdCommitRequest* cmd_commit_req_;
  ::kvrpcpb::CmdCleanupRequest* cmd_cleanup_req_;
  ::kvrpcpb::CmdBatchGetRequest* cmd_batch_get_req_;
  ::kvrpcpb::CmdBatchRollbackRequest* cmd_batch_rollback_req_;
  ::kvrpcpb::CmdScanLockRequest* cmd_scan_lock_req_;
  ::kvrpcpb::CmdResolveLockRequest* cmd_resolve_lock_req_;
  ::kvrpcpb::CmdGCRequest* cmd_gc_req_;
  ::kvrpcpb::CmdRawGetRequest* cmd_raw_get_req_;
  ::kvrpcpb::CmdRawPutRequest* cmd_raw_put_req_;
  ::kvrpcpb::CmdRawDeleteRequest* cmd_raw_delete_req_;
  int type_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .kvrpcpb.MessageType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::kvrpcpb::MessageType type() const;
  inline void set_type(::kvrpcpb::MessageType value);

  // optional .errorpb.Error region_error = 2;
  inline bool has_region_error() const;
  inline void clear_region_error();
  static const int kRegionErrorFieldNumber = 2;
  inline const ::errorpb::Error& region_error() const;
  inline ::errorpb::Error* mutable_region_error();
  inline ::errorpb::Error* release_region_error();
  inline void set_allocated_region_error(::errorpb::Error* region_error);

  // optional .kvrpcpb.CmdGetResponse cmd_get_resp = 3;
  inline bool has_cmd_get_resp() const;
  inline void clear_cmd_get_resp();
  static const int kCmdGetRespFieldNumber = 3;
  inline const ::kvrpcpb::CmdGetResponse& cmd_get_resp() const;
  inline ::kvrpcpb::CmdGetResponse* mutable_cmd_get_resp();
  inline ::kvrpcpb::CmdGetResponse* release_cmd_get_resp();
  inline void set_allocated_cmd_get_resp(::kvrpcpb::CmdGetResponse* cmd_get_resp);

  // optional .kvrpcpb.CmdScanResponse cmd_scan_resp = 4;
  inline bool has_cmd_scan_resp() const;
  inline void clear_cmd_scan_resp();
  static const int kCmdScanRespFieldNumber = 4;
  inline const ::kvrpcpb::CmdScanResponse& cmd_scan_resp() const;
  inline ::kvrpcpb::CmdScanResponse* mutable_cmd_scan_resp();
  inline ::kvrpcpb::CmdScanResponse* release_cmd_scan_resp();
  inline void set_allocated_cmd_scan_resp(::kvrpcpb::CmdScanResponse* cmd_scan_resp);

  // optional .kvrpcpb.CmdPrewriteResponse cmd_prewrite_resp = 5;
  inline bool has_cmd_prewrite_resp() const;
  inline void clear_cmd_prewrite_resp();
  static const int kCmdPrewriteRespFieldNumber = 5;
  inline const ::kvrpcpb::CmdPrewriteResponse& cmd_prewrite_resp() const;
  inline ::kvrpcpb::CmdPrewriteResponse* mutable_cmd_prewrite_resp();
  inline ::kvrpcpb::CmdPrewriteResponse* release_cmd_prewrite_resp();
  inline void set_allocated_cmd_prewrite_resp(::kvrpcpb::CmdPrewriteResponse* cmd_prewrite_resp);

  // optional .kvrpcpb.CmdCommitResponse cmd_commit_resp = 6;
  inline bool has_cmd_commit_resp() const;
  inline void clear_cmd_commit_resp();
  static const int kCmdCommitRespFieldNumber = 6;
  inline const ::kvrpcpb::CmdCommitResponse& cmd_commit_resp() const;
  inline ::kvrpcpb::CmdCommitResponse* mutable_cmd_commit_resp();
  inline ::kvrpcpb::CmdCommitResponse* release_cmd_commit_resp();
  inline void set_allocated_cmd_commit_resp(::kvrpcpb::CmdCommitResponse* cmd_commit_resp);

  // optional .kvrpcpb.CmdCleanupResponse cmd_cleanup_resp = 7;
  inline bool has_cmd_cleanup_resp() const;
  inline void clear_cmd_cleanup_resp();
  static const int kCmdCleanupRespFieldNumber = 7;
  inline const ::kvrpcpb::CmdCleanupResponse& cmd_cleanup_resp() const;
  inline ::kvrpcpb::CmdCleanupResponse* mutable_cmd_cleanup_resp();
  inline ::kvrpcpb::CmdCleanupResponse* release_cmd_cleanup_resp();
  inline void set_allocated_cmd_cleanup_resp(::kvrpcpb::CmdCleanupResponse* cmd_cleanup_resp);

  // optional .kvrpcpb.CmdBatchGetResponse cmd_batch_get_resp = 10;
  inline bool has_cmd_batch_get_resp() const;
  inline void clear_cmd_batch_get_resp();
  static const int kCmdBatchGetRespFieldNumber = 10;
  inline const ::kvrpcpb::CmdBatchGetResponse& cmd_batch_get_resp() const;
  inline ::kvrpcpb::CmdBatchGetResponse* mutable_cmd_batch_get_resp();
  inline ::kvrpcpb::CmdBatchGetResponse* release_cmd_batch_get_resp();
  inline void set_allocated_cmd_batch_get_resp(::kvrpcpb::CmdBatchGetResponse* cmd_batch_get_resp);

  // optional .kvrpcpb.CmdBatchRollbackResponse cmd_batch_rollback_resp = 11;
  inline bool has_cmd_batch_rollback_resp() const;
  inline void clear_cmd_batch_rollback_resp();
  static const int kCmdBatchRollbackRespFieldNumber = 11;
  inline const ::kvrpcpb::CmdBatchRollbackResponse& cmd_batch_rollback_resp() const;
  inline ::kvrpcpb::CmdBatchRollbackResponse* mutable_cmd_batch_rollback_resp();
  inline ::kvrpcpb::CmdBatchRollbackResponse* release_cmd_batch_rollback_resp();
  inline void set_allocated_cmd_batch_rollback_resp(::kvrpcpb::CmdBatchRollbackResponse* cmd_batch_rollback_resp);

  // optional .kvrpcpb.CmdScanLockResponse cmd_scan_lock_resp = 12;
  inline bool has_cmd_scan_lock_resp() const;
  inline void clear_cmd_scan_lock_resp();
  static const int kCmdScanLockRespFieldNumber = 12;
  inline const ::kvrpcpb::CmdScanLockResponse& cmd_scan_lock_resp() const;
  inline ::kvrpcpb::CmdScanLockResponse* mutable_cmd_scan_lock_resp();
  inline ::kvrpcpb::CmdScanLockResponse* release_cmd_scan_lock_resp();
  inline void set_allocated_cmd_scan_lock_resp(::kvrpcpb::CmdScanLockResponse* cmd_scan_lock_resp);

  // optional .kvrpcpb.CmdResolveLockResponse cmd_resolve_lock_resp = 13;
  inline bool has_cmd_resolve_lock_resp() const;
  inline void clear_cmd_resolve_lock_resp();
  static const int kCmdResolveLockRespFieldNumber = 13;
  inline const ::kvrpcpb::CmdResolveLockResponse& cmd_resolve_lock_resp() const;
  inline ::kvrpcpb::CmdResolveLockResponse* mutable_cmd_resolve_lock_resp();
  inline ::kvrpcpb::CmdResolveLockResponse* release_cmd_resolve_lock_resp();
  inline void set_allocated_cmd_resolve_lock_resp(::kvrpcpb::CmdResolveLockResponse* cmd_resolve_lock_resp);

  // optional .kvrpcpb.CmdGCResponse cmd_gc_resp = 14;
  inline bool has_cmd_gc_resp() const;
  inline void clear_cmd_gc_resp();
  static const int kCmdGcRespFieldNumber = 14;
  inline const ::kvrpcpb::CmdGCResponse& cmd_gc_resp() const;
  inline ::kvrpcpb::CmdGCResponse* mutable_cmd_gc_resp();
  inline ::kvrpcpb::CmdGCResponse* release_cmd_gc_resp();
  inline void set_allocated_cmd_gc_resp(::kvrpcpb::CmdGCResponse* cmd_gc_resp);

  // optional .kvrpcpb.CmdRawGetResponse cmd_raw_get_resp = 256;
  inline bool has_cmd_raw_get_resp() const;
  inline void clear_cmd_raw_get_resp();
  static const int kCmdRawGetRespFieldNumber = 256;
  inline const ::kvrpcpb::CmdRawGetResponse& cmd_raw_get_resp() const;
  inline ::kvrpcpb::CmdRawGetResponse* mutable_cmd_raw_get_resp();
  inline ::kvrpcpb::CmdRawGetResponse* release_cmd_raw_get_resp();
  inline void set_allocated_cmd_raw_get_resp(::kvrpcpb::CmdRawGetResponse* cmd_raw_get_resp);

  // optional .kvrpcpb.CmdRawPutResponse cmd_raw_put_resp = 257;
  inline bool has_cmd_raw_put_resp() const;
  inline void clear_cmd_raw_put_resp();
  static const int kCmdRawPutRespFieldNumber = 257;
  inline const ::kvrpcpb::CmdRawPutResponse& cmd_raw_put_resp() const;
  inline ::kvrpcpb::CmdRawPutResponse* mutable_cmd_raw_put_resp();
  inline ::kvrpcpb::CmdRawPutResponse* release_cmd_raw_put_resp();
  inline void set_allocated_cmd_raw_put_resp(::kvrpcpb::CmdRawPutResponse* cmd_raw_put_resp);

  // optional .kvrpcpb.CmdRawDeleteResponse cmd_raw_delete_resp = 258;
  inline bool has_cmd_raw_delete_resp() const;
  inline void clear_cmd_raw_delete_resp();
  static const int kCmdRawDeleteRespFieldNumber = 258;
  inline const ::kvrpcpb::CmdRawDeleteResponse& cmd_raw_delete_resp() const;
  inline ::kvrpcpb::CmdRawDeleteResponse* mutable_cmd_raw_delete_resp();
  inline ::kvrpcpb::CmdRawDeleteResponse* release_cmd_raw_delete_resp();
  inline void set_allocated_cmd_raw_delete_resp(::kvrpcpb::CmdRawDeleteResponse* cmd_raw_delete_resp);

  // @@protoc_insertion_point(class_scope:kvrpcpb.Response)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_region_error();
  inline void clear_has_region_error();
  inline void set_has_cmd_get_resp();
  inline void clear_has_cmd_get_resp();
  inline void set_has_cmd_scan_resp();
  inline void clear_has_cmd_scan_resp();
  inline void set_has_cmd_prewrite_resp();
  inline void clear_has_cmd_prewrite_resp();
  inline void set_has_cmd_commit_resp();
  inline void clear_has_cmd_commit_resp();
  inline void set_has_cmd_cleanup_resp();
  inline void clear_has_cmd_cleanup_resp();
  inline void set_has_cmd_batch_get_resp();
  inline void clear_has_cmd_batch_get_resp();
  inline void set_has_cmd_batch_rollback_resp();
  inline void clear_has_cmd_batch_rollback_resp();
  inline void set_has_cmd_scan_lock_resp();
  inline void clear_has_cmd_scan_lock_resp();
  inline void set_has_cmd_resolve_lock_resp();
  inline void clear_has_cmd_resolve_lock_resp();
  inline void set_has_cmd_gc_resp();
  inline void clear_has_cmd_gc_resp();
  inline void set_has_cmd_raw_get_resp();
  inline void clear_has_cmd_raw_get_resp();
  inline void set_has_cmd_raw_put_resp();
  inline void clear_has_cmd_raw_put_resp();
  inline void set_has_cmd_raw_delete_resp();
  inline void clear_has_cmd_raw_delete_resp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::errorpb::Error* region_error_;
  ::kvrpcpb::CmdGetResponse* cmd_get_resp_;
  ::kvrpcpb::CmdScanResponse* cmd_scan_resp_;
  ::kvrpcpb::CmdPrewriteResponse* cmd_prewrite_resp_;
  ::kvrpcpb::CmdCommitResponse* cmd_commit_resp_;
  ::kvrpcpb::CmdCleanupResponse* cmd_cleanup_resp_;
  ::kvrpcpb::CmdBatchGetResponse* cmd_batch_get_resp_;
  ::kvrpcpb::CmdBatchRollbackResponse* cmd_batch_rollback_resp_;
  ::kvrpcpb::CmdScanLockResponse* cmd_scan_lock_resp_;
  ::kvrpcpb::CmdResolveLockResponse* cmd_resolve_lock_resp_;
  ::kvrpcpb::CmdGCResponse* cmd_gc_resp_;
  ::kvrpcpb::CmdRawGetResponse* cmd_raw_get_resp_;
  ::kvrpcpb::CmdRawPutResponse* cmd_raw_put_resp_;
  ::kvrpcpb::CmdRawDeleteResponse* cmd_raw_delete_resp_;
  int type_;
  friend void  protobuf_AddDesc_kvrpcpb_2eproto();
  friend void protobuf_AssignDesc_kvrpcpb_2eproto();
  friend void protobuf_ShutdownFile_kvrpcpb_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// LockInfo

// optional bytes primary_lock = 1;
inline bool LockInfo::has_primary_lock() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LockInfo::set_has_primary_lock() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LockInfo::clear_has_primary_lock() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LockInfo::clear_primary_lock() {
  if (primary_lock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_->clear();
  }
  clear_has_primary_lock();
}
inline const ::std::string& LockInfo::primary_lock() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.primary_lock)
  return *primary_lock_;
}
inline void LockInfo::set_primary_lock(const ::std::string& value) {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  primary_lock_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.primary_lock)
}
inline void LockInfo::set_primary_lock(const char* value) {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  primary_lock_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockInfo.primary_lock)
}
inline void LockInfo::set_primary_lock(const void* value, size_t size) {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  primary_lock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockInfo.primary_lock)
}
inline ::std::string* LockInfo::mutable_primary_lock() {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.primary_lock)
  return primary_lock_;
}
inline ::std::string* LockInfo::release_primary_lock() {
  clear_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = primary_lock_;
    primary_lock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LockInfo::set_allocated_primary_lock(::std::string* primary_lock) {
  if (primary_lock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete primary_lock_;
  }
  if (primary_lock) {
    set_has_primary_lock();
    primary_lock_ = primary_lock;
  } else {
    clear_has_primary_lock();
    primary_lock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.primary_lock)
}

// optional uint64 lock_version = 2;
inline bool LockInfo::has_lock_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LockInfo::set_has_lock_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LockInfo::clear_has_lock_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LockInfo::clear_lock_version() {
  lock_version_ = GOOGLE_ULONGLONG(0);
  clear_has_lock_version();
}
inline ::google::protobuf::uint64 LockInfo::lock_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.lock_version)
  return lock_version_;
}
inline void LockInfo::set_lock_version(::google::protobuf::uint64 value) {
  set_has_lock_version();
  lock_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.lock_version)
}

// optional bytes key = 3;
inline bool LockInfo::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LockInfo::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LockInfo::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LockInfo::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& LockInfo::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.key)
  return *key_;
}
inline void LockInfo::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.key)
}
inline void LockInfo::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.LockInfo.key)
}
inline void LockInfo::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.LockInfo.key)
}
inline ::std::string* LockInfo::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.LockInfo.key)
  return key_;
}
inline ::std::string* LockInfo::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LockInfo::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.LockInfo.key)
}

// optional uint64 lock_ttl = 4;
inline bool LockInfo::has_lock_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LockInfo::set_has_lock_ttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LockInfo::clear_has_lock_ttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LockInfo::clear_lock_ttl() {
  lock_ttl_ = GOOGLE_ULONGLONG(0);
  clear_has_lock_ttl();
}
inline ::google::protobuf::uint64 LockInfo::lock_ttl() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.LockInfo.lock_ttl)
  return lock_ttl_;
}
inline void LockInfo::set_lock_ttl(::google::protobuf::uint64 value) {
  set_has_lock_ttl();
  lock_ttl_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.LockInfo.lock_ttl)
}

// -------------------------------------------------------------------

// KeyError

// optional .kvrpcpb.LockInfo locked = 1;
inline bool KeyError::has_locked() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyError::set_has_locked() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyError::clear_has_locked() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyError::clear_locked() {
  if (locked_ != NULL) locked_->::kvrpcpb::LockInfo::Clear();
  clear_has_locked();
}
inline const ::kvrpcpb::LockInfo& KeyError::locked() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyError.locked)
  return locked_ != NULL ? *locked_ : *default_instance_->locked_;
}
inline ::kvrpcpb::LockInfo* KeyError::mutable_locked() {
  set_has_locked();
  if (locked_ == NULL) locked_ = new ::kvrpcpb::LockInfo;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyError.locked)
  return locked_;
}
inline ::kvrpcpb::LockInfo* KeyError::release_locked() {
  clear_has_locked();
  ::kvrpcpb::LockInfo* temp = locked_;
  locked_ = NULL;
  return temp;
}
inline void KeyError::set_allocated_locked(::kvrpcpb::LockInfo* locked) {
  delete locked_;
  locked_ = locked;
  if (locked) {
    set_has_locked();
  } else {
    clear_has_locked();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyError.locked)
}

// optional string retryable = 2;
inline bool KeyError::has_retryable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyError::set_has_retryable() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyError::clear_has_retryable() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyError::clear_retryable() {
  if (retryable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retryable_->clear();
  }
  clear_has_retryable();
}
inline const ::std::string& KeyError::retryable() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyError.retryable)
  return *retryable_;
}
inline void KeyError::set_retryable(const ::std::string& value) {
  set_has_retryable();
  if (retryable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retryable_ = new ::std::string;
  }
  retryable_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyError.retryable)
}
inline void KeyError::set_retryable(const char* value) {
  set_has_retryable();
  if (retryable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retryable_ = new ::std::string;
  }
  retryable_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyError.retryable)
}
inline void KeyError::set_retryable(const char* value, size_t size) {
  set_has_retryable();
  if (retryable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retryable_ = new ::std::string;
  }
  retryable_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyError.retryable)
}
inline ::std::string* KeyError::mutable_retryable() {
  set_has_retryable();
  if (retryable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    retryable_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyError.retryable)
  return retryable_;
}
inline ::std::string* KeyError::release_retryable() {
  clear_has_retryable();
  if (retryable_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = retryable_;
    retryable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyError::set_allocated_retryable(::std::string* retryable) {
  if (retryable_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete retryable_;
  }
  if (retryable) {
    set_has_retryable();
    retryable_ = retryable;
  } else {
    clear_has_retryable();
    retryable_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyError.retryable)
}

// optional string abort = 3;
inline bool KeyError::has_abort() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyError::set_has_abort() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyError::clear_has_abort() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyError::clear_abort() {
  if (abort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    abort_->clear();
  }
  clear_has_abort();
}
inline const ::std::string& KeyError::abort() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KeyError.abort)
  return *abort_;
}
inline void KeyError::set_abort(const ::std::string& value) {
  set_has_abort();
  if (abort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    abort_ = new ::std::string;
  }
  abort_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KeyError.abort)
}
inline void KeyError::set_abort(const char* value) {
  set_has_abort();
  if (abort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    abort_ = new ::std::string;
  }
  abort_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KeyError.abort)
}
inline void KeyError::set_abort(const char* value, size_t size) {
  set_has_abort();
  if (abort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    abort_ = new ::std::string;
  }
  abort_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KeyError.abort)
}
inline ::std::string* KeyError::mutable_abort() {
  set_has_abort();
  if (abort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    abort_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KeyError.abort)
  return abort_;
}
inline ::std::string* KeyError::release_abort() {
  clear_has_abort();
  if (abort_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = abort_;
    abort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KeyError::set_allocated_abort(::std::string* abort) {
  if (abort_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete abort_;
  }
  if (abort) {
    set_has_abort();
    abort_ = abort;
  } else {
    clear_has_abort();
    abort_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KeyError.abort)
}

// -------------------------------------------------------------------

// Context

// optional uint64 region_id = 1;
inline bool Context::has_region_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Context::set_has_region_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Context::clear_has_region_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Context::clear_region_id() {
  region_id_ = GOOGLE_ULONGLONG(0);
  clear_has_region_id();
}
inline ::google::protobuf::uint64 Context::region_id() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.region_id)
  return region_id_;
}
inline void Context::set_region_id(::google::protobuf::uint64 value) {
  set_has_region_id();
  region_id_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.region_id)
}

// optional .metapb.RegionEpoch region_epoch = 2;
inline bool Context::has_region_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Context::set_has_region_epoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Context::clear_has_region_epoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Context::clear_region_epoch() {
  if (region_epoch_ != NULL) region_epoch_->::metapb::RegionEpoch::Clear();
  clear_has_region_epoch();
}
inline const ::metapb::RegionEpoch& Context::region_epoch() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.region_epoch)
  return region_epoch_ != NULL ? *region_epoch_ : *default_instance_->region_epoch_;
}
inline ::metapb::RegionEpoch* Context::mutable_region_epoch() {
  set_has_region_epoch();
  if (region_epoch_ == NULL) region_epoch_ = new ::metapb::RegionEpoch;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Context.region_epoch)
  return region_epoch_;
}
inline ::metapb::RegionEpoch* Context::release_region_epoch() {
  clear_has_region_epoch();
  ::metapb::RegionEpoch* temp = region_epoch_;
  region_epoch_ = NULL;
  return temp;
}
inline void Context::set_allocated_region_epoch(::metapb::RegionEpoch* region_epoch) {
  delete region_epoch_;
  region_epoch_ = region_epoch;
  if (region_epoch) {
    set_has_region_epoch();
  } else {
    clear_has_region_epoch();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Context.region_epoch)
}

// optional .metapb.Peer peer = 3;
inline bool Context::has_peer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Context::set_has_peer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Context::clear_has_peer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Context::clear_peer() {
  if (peer_ != NULL) peer_->::metapb::Peer::Clear();
  clear_has_peer();
}
inline const ::metapb::Peer& Context::peer() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.peer)
  return peer_ != NULL ? *peer_ : *default_instance_->peer_;
}
inline ::metapb::Peer* Context::mutable_peer() {
  set_has_peer();
  if (peer_ == NULL) peer_ = new ::metapb::Peer;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Context.peer)
  return peer_;
}
inline ::metapb::Peer* Context::release_peer() {
  clear_has_peer();
  ::metapb::Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline void Context::set_allocated_peer(::metapb::Peer* peer) {
  delete peer_;
  peer_ = peer;
  if (peer) {
    set_has_peer();
  } else {
    clear_has_peer();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Context.peer)
}

// optional bool read_quorum = 4;
inline bool Context::has_read_quorum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Context::set_has_read_quorum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Context::clear_has_read_quorum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Context::clear_read_quorum() {
  read_quorum_ = false;
  clear_has_read_quorum();
}
inline bool Context::read_quorum() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.read_quorum)
  return read_quorum_;
}
inline void Context::set_read_quorum(bool value) {
  set_has_read_quorum();
  read_quorum_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.read_quorum)
}

// optional uint64 term = 5;
inline bool Context::has_term() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Context::set_has_term() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Context::clear_has_term() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Context::clear_term() {
  term_ = GOOGLE_ULONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::uint64 Context::term() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Context.term)
  return term_;
}
inline void Context::set_term(::google::protobuf::uint64 value) {
  set_has_term();
  term_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Context.term)
}

// -------------------------------------------------------------------

// CmdGetRequest

// optional bytes key = 1;
inline bool CmdGetRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdGetRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdGetRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdGetRequest::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CmdGetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdGetRequest.key)
  return *key_;
}
inline void CmdGetRequest::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdGetRequest.key)
}
inline void CmdGetRequest::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdGetRequest.key)
}
inline void CmdGetRequest::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdGetRequest.key)
}
inline ::std::string* CmdGetRequest::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdGetRequest.key)
  return key_;
}
inline ::std::string* CmdGetRequest::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdGetRequest::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdGetRequest.key)
}

// optional uint64 version = 2;
inline bool CmdGetRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdGetRequest::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdGetRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdGetRequest::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 CmdGetRequest::version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdGetRequest.version)
  return version_;
}
inline void CmdGetRequest::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdGetRequest.version)
}

// -------------------------------------------------------------------

// CmdGetResponse

// optional .kvrpcpb.KeyError error = 1;
inline bool CmdGetResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdGetResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdGetResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdGetResponse::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& CmdGetResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdGetResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* CmdGetResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdGetResponse.error)
  return error_;
}
inline ::kvrpcpb::KeyError* CmdGetResponse::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CmdGetResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdGetResponse.error)
}

// optional bytes value = 2;
inline bool CmdGetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdGetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdGetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdGetResponse::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CmdGetResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdGetResponse.value)
  return *value_;
}
inline void CmdGetResponse::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdGetResponse.value)
}
inline void CmdGetResponse::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdGetResponse.value)
}
inline void CmdGetResponse::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdGetResponse.value)
}
inline ::std::string* CmdGetResponse::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdGetResponse.value)
  return value_;
}
inline ::std::string* CmdGetResponse::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdGetResponse::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdGetResponse.value)
}

// -------------------------------------------------------------------

// CmdScanRequest

// optional bytes start_key = 1;
inline bool CmdScanRequest::has_start_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdScanRequest::set_has_start_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdScanRequest::clear_has_start_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdScanRequest::clear_start_key() {
  if (start_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_->clear();
  }
  clear_has_start_key();
}
inline const ::std::string& CmdScanRequest::start_key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanRequest.start_key)
  return *start_key_;
}
inline void CmdScanRequest::set_start_key(const ::std::string& value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdScanRequest.start_key)
}
inline void CmdScanRequest::set_start_key(const char* value) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdScanRequest.start_key)
}
inline void CmdScanRequest::set_start_key(const void* value, size_t size) {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  start_key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdScanRequest.start_key)
}
inline ::std::string* CmdScanRequest::mutable_start_key() {
  set_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    start_key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdScanRequest.start_key)
  return start_key_;
}
inline ::std::string* CmdScanRequest::release_start_key() {
  clear_has_start_key();
  if (start_key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = start_key_;
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdScanRequest::set_allocated_start_key(::std::string* start_key) {
  if (start_key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete start_key_;
  }
  if (start_key) {
    set_has_start_key();
    start_key_ = start_key;
  } else {
    clear_has_start_key();
    start_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdScanRequest.start_key)
}

// optional uint32 limit = 2;
inline bool CmdScanRequest::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdScanRequest::set_has_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdScanRequest::clear_has_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdScanRequest::clear_limit() {
  limit_ = 0u;
  clear_has_limit();
}
inline ::google::protobuf::uint32 CmdScanRequest::limit() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanRequest.limit)
  return limit_;
}
inline void CmdScanRequest::set_limit(::google::protobuf::uint32 value) {
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdScanRequest.limit)
}

// optional uint64 version = 3;
inline bool CmdScanRequest::has_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CmdScanRequest::set_has_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CmdScanRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CmdScanRequest::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 CmdScanRequest::version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanRequest.version)
  return version_;
}
inline void CmdScanRequest::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdScanRequest.version)
}

// optional bool key_only = 4;
inline bool CmdScanRequest::has_key_only() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CmdScanRequest::set_has_key_only() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CmdScanRequest::clear_has_key_only() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CmdScanRequest::clear_key_only() {
  key_only_ = false;
  clear_has_key_only();
}
inline bool CmdScanRequest::key_only() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanRequest.key_only)
  return key_only_;
}
inline void CmdScanRequest::set_key_only(bool value) {
  set_has_key_only();
  key_only_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdScanRequest.key_only)
}

// -------------------------------------------------------------------

// KvPair

// optional .kvrpcpb.KeyError error = 1;
inline bool KvPair::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KvPair::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KvPair::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KvPair::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& KvPair::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* KvPair::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.error)
  return error_;
}
inline ::kvrpcpb::KeyError* KvPair::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void KvPair::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.error)
}

// optional bytes key = 2;
inline bool KvPair::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KvPair::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KvPair::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KvPair::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KvPair::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.key)
  return *key_;
}
inline void KvPair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.key)
}
inline void KvPair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.key)
}
inline void KvPair::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.key)
}
inline ::std::string* KvPair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.key)
  return key_;
}
inline ::std::string* KvPair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KvPair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.key)
}

// optional bytes value = 3;
inline bool KvPair::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KvPair::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KvPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KvPair::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& KvPair::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.KvPair.value)
  return *value_;
}
inline void KvPair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.KvPair.value)
}
inline void KvPair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.KvPair.value)
}
inline void KvPair::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.KvPair.value)
}
inline ::std::string* KvPair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.KvPair.value)
  return value_;
}
inline ::std::string* KvPair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void KvPair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.KvPair.value)
}

// -------------------------------------------------------------------

// CmdScanResponse

// repeated .kvrpcpb.KvPair pairs = 1;
inline int CmdScanResponse::pairs_size() const {
  return pairs_.size();
}
inline void CmdScanResponse::clear_pairs() {
  pairs_.Clear();
}
inline const ::kvrpcpb::KvPair& CmdScanResponse::pairs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanResponse.pairs)
  return pairs_.Get(index);
}
inline ::kvrpcpb::KvPair* CmdScanResponse::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdScanResponse.pairs)
  return pairs_.Mutable(index);
}
inline ::kvrpcpb::KvPair* CmdScanResponse::add_pairs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdScanResponse.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
CmdScanResponse::pairs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdScanResponse.pairs)
  return pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
CmdScanResponse::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdScanResponse.pairs)
  return &pairs_;
}

// -------------------------------------------------------------------

// Mutation

// optional .kvrpcpb.Op op = 1;
inline bool Mutation::has_op() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mutation::set_has_op() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mutation::clear_has_op() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mutation::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline ::kvrpcpb::Op Mutation::op() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Mutation.op)
  return static_cast< ::kvrpcpb::Op >(op_);
}
inline void Mutation::set_op(::kvrpcpb::Op value) {
  assert(::kvrpcpb::Op_IsValid(value));
  set_has_op();
  op_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Mutation.op)
}

// optional bytes key = 2;
inline bool Mutation::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mutation::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mutation::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mutation::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Mutation::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Mutation.key)
  return *key_;
}
inline void Mutation::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Mutation.key)
}
inline void Mutation::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Mutation.key)
}
inline void Mutation::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Mutation.key)
}
inline ::std::string* Mutation::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Mutation.key)
  return key_;
}
inline ::std::string* Mutation::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mutation::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Mutation.key)
}

// optional bytes value = 3;
inline bool Mutation::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mutation::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mutation::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mutation::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Mutation::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Mutation.value)
  return *value_;
}
inline void Mutation::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.Mutation.value)
}
inline void Mutation::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.Mutation.value)
}
inline void Mutation::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.Mutation.value)
}
inline ::std::string* Mutation::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Mutation.value)
  return value_;
}
inline ::std::string* Mutation::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mutation::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Mutation.value)
}

// -------------------------------------------------------------------

// CmdPrewriteRequest

// repeated .kvrpcpb.Mutation mutations = 1;
inline int CmdPrewriteRequest::mutations_size() const {
  return mutations_.size();
}
inline void CmdPrewriteRequest::clear_mutations() {
  mutations_.Clear();
}
inline const ::kvrpcpb::Mutation& CmdPrewriteRequest::mutations(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdPrewriteRequest.mutations)
  return mutations_.Get(index);
}
inline ::kvrpcpb::Mutation* CmdPrewriteRequest::mutable_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdPrewriteRequest.mutations)
  return mutations_.Mutable(index);
}
inline ::kvrpcpb::Mutation* CmdPrewriteRequest::add_mutations() {
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdPrewriteRequest.mutations)
  return mutations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >&
CmdPrewriteRequest::mutations() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdPrewriteRequest.mutations)
  return mutations_;
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::Mutation >*
CmdPrewriteRequest::mutable_mutations() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdPrewriteRequest.mutations)
  return &mutations_;
}

// optional bytes primary_lock = 2;
inline bool CmdPrewriteRequest::has_primary_lock() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdPrewriteRequest::set_has_primary_lock() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdPrewriteRequest::clear_has_primary_lock() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdPrewriteRequest::clear_primary_lock() {
  if (primary_lock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_->clear();
  }
  clear_has_primary_lock();
}
inline const ::std::string& CmdPrewriteRequest::primary_lock() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdPrewriteRequest.primary_lock)
  return *primary_lock_;
}
inline void CmdPrewriteRequest::set_primary_lock(const ::std::string& value) {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  primary_lock_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdPrewriteRequest.primary_lock)
}
inline void CmdPrewriteRequest::set_primary_lock(const char* value) {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  primary_lock_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdPrewriteRequest.primary_lock)
}
inline void CmdPrewriteRequest::set_primary_lock(const void* value, size_t size) {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  primary_lock_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdPrewriteRequest.primary_lock)
}
inline ::std::string* CmdPrewriteRequest::mutable_primary_lock() {
  set_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    primary_lock_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdPrewriteRequest.primary_lock)
  return primary_lock_;
}
inline ::std::string* CmdPrewriteRequest::release_primary_lock() {
  clear_has_primary_lock();
  if (primary_lock_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = primary_lock_;
    primary_lock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdPrewriteRequest::set_allocated_primary_lock(::std::string* primary_lock) {
  if (primary_lock_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete primary_lock_;
  }
  if (primary_lock) {
    set_has_primary_lock();
    primary_lock_ = primary_lock;
  } else {
    clear_has_primary_lock();
    primary_lock_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdPrewriteRequest.primary_lock)
}

// optional uint64 start_version = 3;
inline bool CmdPrewriteRequest::has_start_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CmdPrewriteRequest::set_has_start_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CmdPrewriteRequest::clear_has_start_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CmdPrewriteRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
  clear_has_start_version();
}
inline ::google::protobuf::uint64 CmdPrewriteRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdPrewriteRequest.start_version)
  return start_version_;
}
inline void CmdPrewriteRequest::set_start_version(::google::protobuf::uint64 value) {
  set_has_start_version();
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdPrewriteRequest.start_version)
}

// optional uint64 lock_ttl = 4;
inline bool CmdPrewriteRequest::has_lock_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CmdPrewriteRequest::set_has_lock_ttl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CmdPrewriteRequest::clear_has_lock_ttl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CmdPrewriteRequest::clear_lock_ttl() {
  lock_ttl_ = GOOGLE_ULONGLONG(0);
  clear_has_lock_ttl();
}
inline ::google::protobuf::uint64 CmdPrewriteRequest::lock_ttl() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdPrewriteRequest.lock_ttl)
  return lock_ttl_;
}
inline void CmdPrewriteRequest::set_lock_ttl(::google::protobuf::uint64 value) {
  set_has_lock_ttl();
  lock_ttl_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdPrewriteRequest.lock_ttl)
}

// optional bool skip_constraint_check = 5;
inline bool CmdPrewriteRequest::has_skip_constraint_check() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CmdPrewriteRequest::set_has_skip_constraint_check() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CmdPrewriteRequest::clear_has_skip_constraint_check() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CmdPrewriteRequest::clear_skip_constraint_check() {
  skip_constraint_check_ = false;
  clear_has_skip_constraint_check();
}
inline bool CmdPrewriteRequest::skip_constraint_check() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdPrewriteRequest.skip_constraint_check)
  return skip_constraint_check_;
}
inline void CmdPrewriteRequest::set_skip_constraint_check(bool value) {
  set_has_skip_constraint_check();
  skip_constraint_check_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdPrewriteRequest.skip_constraint_check)
}

// -------------------------------------------------------------------

// CmdPrewriteResponse

// repeated .kvrpcpb.KeyError errors = 1;
inline int CmdPrewriteResponse::errors_size() const {
  return errors_.size();
}
inline void CmdPrewriteResponse::clear_errors() {
  errors_.Clear();
}
inline const ::kvrpcpb::KeyError& CmdPrewriteResponse::errors(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdPrewriteResponse.errors)
  return errors_.Get(index);
}
inline ::kvrpcpb::KeyError* CmdPrewriteResponse::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdPrewriteResponse.errors)
  return errors_.Mutable(index);
}
inline ::kvrpcpb::KeyError* CmdPrewriteResponse::add_errors() {
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdPrewriteResponse.errors)
  return errors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >&
CmdPrewriteResponse::errors() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdPrewriteResponse.errors)
  return errors_;
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KeyError >*
CmdPrewriteResponse::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdPrewriteResponse.errors)
  return &errors_;
}

// -------------------------------------------------------------------

// CmdCommitRequest

// optional uint64 start_version = 1;
inline bool CmdCommitRequest::has_start_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdCommitRequest::set_has_start_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdCommitRequest::clear_has_start_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdCommitRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
  clear_has_start_version();
}
inline ::google::protobuf::uint64 CmdCommitRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCommitRequest.start_version)
  return start_version_;
}
inline void CmdCommitRequest::set_start_version(::google::protobuf::uint64 value) {
  set_has_start_version();
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdCommitRequest.start_version)
}

// repeated bytes keys = 2;
inline int CmdCommitRequest::keys_size() const {
  return keys_.size();
}
inline void CmdCommitRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& CmdCommitRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCommitRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* CmdCommitRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdCommitRequest.keys)
  return keys_.Mutable(index);
}
inline void CmdCommitRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdCommitRequest.keys)
  keys_.Mutable(index)->assign(value);
}
inline void CmdCommitRequest::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdCommitRequest.keys)
}
inline void CmdCommitRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdCommitRequest.keys)
}
inline ::std::string* CmdCommitRequest::add_keys() {
  return keys_.Add();
}
inline void CmdCommitRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdCommitRequest.keys)
}
inline void CmdCommitRequest::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.CmdCommitRequest.keys)
}
inline void CmdCommitRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.CmdCommitRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CmdCommitRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdCommitRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CmdCommitRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdCommitRequest.keys)
  return &keys_;
}

// optional uint64 commit_version = 3;
inline bool CmdCommitRequest::has_commit_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CmdCommitRequest::set_has_commit_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CmdCommitRequest::clear_has_commit_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CmdCommitRequest::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
  clear_has_commit_version();
}
inline ::google::protobuf::uint64 CmdCommitRequest::commit_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCommitRequest.commit_version)
  return commit_version_;
}
inline void CmdCommitRequest::set_commit_version(::google::protobuf::uint64 value) {
  set_has_commit_version();
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdCommitRequest.commit_version)
}

// optional bytes binlog = 4;
inline bool CmdCommitRequest::has_binlog() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CmdCommitRequest::set_has_binlog() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CmdCommitRequest::clear_has_binlog() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CmdCommitRequest::clear_binlog() {
  if (binlog_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    binlog_->clear();
  }
  clear_has_binlog();
}
inline const ::std::string& CmdCommitRequest::binlog() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCommitRequest.binlog)
  return *binlog_;
}
inline void CmdCommitRequest::set_binlog(const ::std::string& value) {
  set_has_binlog();
  if (binlog_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    binlog_ = new ::std::string;
  }
  binlog_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdCommitRequest.binlog)
}
inline void CmdCommitRequest::set_binlog(const char* value) {
  set_has_binlog();
  if (binlog_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    binlog_ = new ::std::string;
  }
  binlog_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdCommitRequest.binlog)
}
inline void CmdCommitRequest::set_binlog(const void* value, size_t size) {
  set_has_binlog();
  if (binlog_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    binlog_ = new ::std::string;
  }
  binlog_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdCommitRequest.binlog)
}
inline ::std::string* CmdCommitRequest::mutable_binlog() {
  set_has_binlog();
  if (binlog_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    binlog_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdCommitRequest.binlog)
  return binlog_;
}
inline ::std::string* CmdCommitRequest::release_binlog() {
  clear_has_binlog();
  if (binlog_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = binlog_;
    binlog_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdCommitRequest::set_allocated_binlog(::std::string* binlog) {
  if (binlog_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete binlog_;
  }
  if (binlog) {
    set_has_binlog();
    binlog_ = binlog;
  } else {
    clear_has_binlog();
    binlog_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdCommitRequest.binlog)
}

// -------------------------------------------------------------------

// CmdCommitResponse

// optional .kvrpcpb.KeyError error = 1;
inline bool CmdCommitResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdCommitResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdCommitResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdCommitResponse::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& CmdCommitResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCommitResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* CmdCommitResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdCommitResponse.error)
  return error_;
}
inline ::kvrpcpb::KeyError* CmdCommitResponse::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CmdCommitResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdCommitResponse.error)
}

// -------------------------------------------------------------------

// CmdBatchRollbackRequest

// optional uint64 start_version = 1;
inline bool CmdBatchRollbackRequest::has_start_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdBatchRollbackRequest::set_has_start_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdBatchRollbackRequest::clear_has_start_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdBatchRollbackRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
  clear_has_start_version();
}
inline ::google::protobuf::uint64 CmdBatchRollbackRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdBatchRollbackRequest.start_version)
  return start_version_;
}
inline void CmdBatchRollbackRequest::set_start_version(::google::protobuf::uint64 value) {
  set_has_start_version();
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdBatchRollbackRequest.start_version)
}

// repeated bytes keys = 2;
inline int CmdBatchRollbackRequest::keys_size() const {
  return keys_.size();
}
inline void CmdBatchRollbackRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& CmdBatchRollbackRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdBatchRollbackRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* CmdBatchRollbackRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdBatchRollbackRequest.keys)
  return keys_.Mutable(index);
}
inline void CmdBatchRollbackRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdBatchRollbackRequest.keys)
  keys_.Mutable(index)->assign(value);
}
inline void CmdBatchRollbackRequest::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdBatchRollbackRequest.keys)
}
inline void CmdBatchRollbackRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdBatchRollbackRequest.keys)
}
inline ::std::string* CmdBatchRollbackRequest::add_keys() {
  return keys_.Add();
}
inline void CmdBatchRollbackRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdBatchRollbackRequest.keys)
}
inline void CmdBatchRollbackRequest::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.CmdBatchRollbackRequest.keys)
}
inline void CmdBatchRollbackRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.CmdBatchRollbackRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CmdBatchRollbackRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdBatchRollbackRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CmdBatchRollbackRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdBatchRollbackRequest.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// CmdBatchRollbackResponse

// optional .kvrpcpb.KeyError error = 1;
inline bool CmdBatchRollbackResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdBatchRollbackResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdBatchRollbackResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdBatchRollbackResponse::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& CmdBatchRollbackResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdBatchRollbackResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* CmdBatchRollbackResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdBatchRollbackResponse.error)
  return error_;
}
inline ::kvrpcpb::KeyError* CmdBatchRollbackResponse::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CmdBatchRollbackResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdBatchRollbackResponse.error)
}

// -------------------------------------------------------------------

// CmdCleanupRequest

// optional bytes key = 1;
inline bool CmdCleanupRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdCleanupRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdCleanupRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdCleanupRequest::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CmdCleanupRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCleanupRequest.key)
  return *key_;
}
inline void CmdCleanupRequest::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdCleanupRequest.key)
}
inline void CmdCleanupRequest::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdCleanupRequest.key)
}
inline void CmdCleanupRequest::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdCleanupRequest.key)
}
inline ::std::string* CmdCleanupRequest::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdCleanupRequest.key)
  return key_;
}
inline ::std::string* CmdCleanupRequest::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdCleanupRequest::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdCleanupRequest.key)
}

// optional uint64 start_version = 2;
inline bool CmdCleanupRequest::has_start_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdCleanupRequest::set_has_start_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdCleanupRequest::clear_has_start_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdCleanupRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
  clear_has_start_version();
}
inline ::google::protobuf::uint64 CmdCleanupRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCleanupRequest.start_version)
  return start_version_;
}
inline void CmdCleanupRequest::set_start_version(::google::protobuf::uint64 value) {
  set_has_start_version();
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdCleanupRequest.start_version)
}

// -------------------------------------------------------------------

// CmdCleanupResponse

// optional .kvrpcpb.KeyError error = 1;
inline bool CmdCleanupResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdCleanupResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdCleanupResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdCleanupResponse::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& CmdCleanupResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCleanupResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* CmdCleanupResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdCleanupResponse.error)
  return error_;
}
inline ::kvrpcpb::KeyError* CmdCleanupResponse::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CmdCleanupResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdCleanupResponse.error)
}

// optional uint64 commit_version = 2;
inline bool CmdCleanupResponse::has_commit_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdCleanupResponse::set_has_commit_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdCleanupResponse::clear_has_commit_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdCleanupResponse::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
  clear_has_commit_version();
}
inline ::google::protobuf::uint64 CmdCleanupResponse::commit_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdCleanupResponse.commit_version)
  return commit_version_;
}
inline void CmdCleanupResponse::set_commit_version(::google::protobuf::uint64 value) {
  set_has_commit_version();
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdCleanupResponse.commit_version)
}

// -------------------------------------------------------------------

// CmdBatchGetRequest

// repeated bytes keys = 1;
inline int CmdBatchGetRequest::keys_size() const {
  return keys_.size();
}
inline void CmdBatchGetRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& CmdBatchGetRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdBatchGetRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* CmdBatchGetRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdBatchGetRequest.keys)
  return keys_.Mutable(index);
}
inline void CmdBatchGetRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdBatchGetRequest.keys)
  keys_.Mutable(index)->assign(value);
}
inline void CmdBatchGetRequest::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdBatchGetRequest.keys)
}
inline void CmdBatchGetRequest::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdBatchGetRequest.keys)
}
inline ::std::string* CmdBatchGetRequest::add_keys() {
  return keys_.Add();
}
inline void CmdBatchGetRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdBatchGetRequest.keys)
}
inline void CmdBatchGetRequest::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:kvrpcpb.CmdBatchGetRequest.keys)
}
inline void CmdBatchGetRequest::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:kvrpcpb.CmdBatchGetRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CmdBatchGetRequest::keys() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdBatchGetRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CmdBatchGetRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdBatchGetRequest.keys)
  return &keys_;
}

// optional uint64 version = 2;
inline bool CmdBatchGetRequest::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdBatchGetRequest::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdBatchGetRequest::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdBatchGetRequest::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 CmdBatchGetRequest::version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdBatchGetRequest.version)
  return version_;
}
inline void CmdBatchGetRequest::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdBatchGetRequest.version)
}

// -------------------------------------------------------------------

// CmdBatchGetResponse

// repeated .kvrpcpb.KvPair pairs = 1;
inline int CmdBatchGetResponse::pairs_size() const {
  return pairs_.size();
}
inline void CmdBatchGetResponse::clear_pairs() {
  pairs_.Clear();
}
inline const ::kvrpcpb::KvPair& CmdBatchGetResponse::pairs(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdBatchGetResponse.pairs)
  return pairs_.Get(index);
}
inline ::kvrpcpb::KvPair* CmdBatchGetResponse::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdBatchGetResponse.pairs)
  return pairs_.Mutable(index);
}
inline ::kvrpcpb::KvPair* CmdBatchGetResponse::add_pairs() {
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdBatchGetResponse.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >&
CmdBatchGetResponse::pairs() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdBatchGetResponse.pairs)
  return pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::KvPair >*
CmdBatchGetResponse::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdBatchGetResponse.pairs)
  return &pairs_;
}

// -------------------------------------------------------------------

// CmdScanLockRequest

// optional uint64 max_version = 1;
inline bool CmdScanLockRequest::has_max_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdScanLockRequest::set_has_max_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdScanLockRequest::clear_has_max_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdScanLockRequest::clear_max_version() {
  max_version_ = GOOGLE_ULONGLONG(0);
  clear_has_max_version();
}
inline ::google::protobuf::uint64 CmdScanLockRequest::max_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanLockRequest.max_version)
  return max_version_;
}
inline void CmdScanLockRequest::set_max_version(::google::protobuf::uint64 value) {
  set_has_max_version();
  max_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdScanLockRequest.max_version)
}

// -------------------------------------------------------------------

// CmdScanLockResponse

// optional .kvrpcpb.KeyError error = 1;
inline bool CmdScanLockResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdScanLockResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdScanLockResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdScanLockResponse::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& CmdScanLockResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanLockResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* CmdScanLockResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdScanLockResponse.error)
  return error_;
}
inline ::kvrpcpb::KeyError* CmdScanLockResponse::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CmdScanLockResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdScanLockResponse.error)
}

// repeated .kvrpcpb.LockInfo locks = 2;
inline int CmdScanLockResponse::locks_size() const {
  return locks_.size();
}
inline void CmdScanLockResponse::clear_locks() {
  locks_.Clear();
}
inline const ::kvrpcpb::LockInfo& CmdScanLockResponse::locks(int index) const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdScanLockResponse.locks)
  return locks_.Get(index);
}
inline ::kvrpcpb::LockInfo* CmdScanLockResponse::mutable_locks(int index) {
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdScanLockResponse.locks)
  return locks_.Mutable(index);
}
inline ::kvrpcpb::LockInfo* CmdScanLockResponse::add_locks() {
  // @@protoc_insertion_point(field_add:kvrpcpb.CmdScanLockResponse.locks)
  return locks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >&
CmdScanLockResponse::locks() const {
  // @@protoc_insertion_point(field_list:kvrpcpb.CmdScanLockResponse.locks)
  return locks_;
}
inline ::google::protobuf::RepeatedPtrField< ::kvrpcpb::LockInfo >*
CmdScanLockResponse::mutable_locks() {
  // @@protoc_insertion_point(field_mutable_list:kvrpcpb.CmdScanLockResponse.locks)
  return &locks_;
}

// -------------------------------------------------------------------

// CmdResolveLockRequest

// optional uint64 start_version = 1;
inline bool CmdResolveLockRequest::has_start_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdResolveLockRequest::set_has_start_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdResolveLockRequest::clear_has_start_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdResolveLockRequest::clear_start_version() {
  start_version_ = GOOGLE_ULONGLONG(0);
  clear_has_start_version();
}
inline ::google::protobuf::uint64 CmdResolveLockRequest::start_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdResolveLockRequest.start_version)
  return start_version_;
}
inline void CmdResolveLockRequest::set_start_version(::google::protobuf::uint64 value) {
  set_has_start_version();
  start_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdResolveLockRequest.start_version)
}

// optional uint64 commit_version = 2;
inline bool CmdResolveLockRequest::has_commit_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdResolveLockRequest::set_has_commit_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdResolveLockRequest::clear_has_commit_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdResolveLockRequest::clear_commit_version() {
  commit_version_ = GOOGLE_ULONGLONG(0);
  clear_has_commit_version();
}
inline ::google::protobuf::uint64 CmdResolveLockRequest::commit_version() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdResolveLockRequest.commit_version)
  return commit_version_;
}
inline void CmdResolveLockRequest::set_commit_version(::google::protobuf::uint64 value) {
  set_has_commit_version();
  commit_version_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdResolveLockRequest.commit_version)
}

// -------------------------------------------------------------------

// CmdResolveLockResponse

// optional .kvrpcpb.KeyError error = 1;
inline bool CmdResolveLockResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdResolveLockResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdResolveLockResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdResolveLockResponse::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& CmdResolveLockResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdResolveLockResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* CmdResolveLockResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdResolveLockResponse.error)
  return error_;
}
inline ::kvrpcpb::KeyError* CmdResolveLockResponse::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CmdResolveLockResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdResolveLockResponse.error)
}

// -------------------------------------------------------------------

// CmdGCRequest

// optional uint64 safe_point = 1;
inline bool CmdGCRequest::has_safe_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdGCRequest::set_has_safe_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdGCRequest::clear_has_safe_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdGCRequest::clear_safe_point() {
  safe_point_ = GOOGLE_ULONGLONG(0);
  clear_has_safe_point();
}
inline ::google::protobuf::uint64 CmdGCRequest::safe_point() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdGCRequest.safe_point)
  return safe_point_;
}
inline void CmdGCRequest::set_safe_point(::google::protobuf::uint64 value) {
  set_has_safe_point();
  safe_point_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdGCRequest.safe_point)
}

// -------------------------------------------------------------------

// CmdGCResponse

// optional .kvrpcpb.KeyError error = 1;
inline bool CmdGCResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdGCResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdGCResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdGCResponse::clear_error() {
  if (error_ != NULL) error_->::kvrpcpb::KeyError::Clear();
  clear_has_error();
}
inline const ::kvrpcpb::KeyError& CmdGCResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdGCResponse.error)
  return error_ != NULL ? *error_ : *default_instance_->error_;
}
inline ::kvrpcpb::KeyError* CmdGCResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::kvrpcpb::KeyError;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdGCResponse.error)
  return error_;
}
inline ::kvrpcpb::KeyError* CmdGCResponse::release_error() {
  clear_has_error();
  ::kvrpcpb::KeyError* temp = error_;
  error_ = NULL;
  return temp;
}
inline void CmdGCResponse::set_allocated_error(::kvrpcpb::KeyError* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdGCResponse.error)
}

// -------------------------------------------------------------------

// CmdRawGetRequest

// optional bytes key = 1;
inline bool CmdRawGetRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdRawGetRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdRawGetRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdRawGetRequest::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CmdRawGetRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawGetRequest.key)
  return *key_;
}
inline void CmdRawGetRequest::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawGetRequest.key)
}
inline void CmdRawGetRequest::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawGetRequest.key)
}
inline void CmdRawGetRequest::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawGetRequest.key)
}
inline ::std::string* CmdRawGetRequest::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawGetRequest.key)
  return key_;
}
inline ::std::string* CmdRawGetRequest::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawGetRequest::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawGetRequest.key)
}

// -------------------------------------------------------------------

// CmdRawGetResponse

// optional string error = 1;
inline bool CmdRawGetResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdRawGetResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdRawGetResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdRawGetResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& CmdRawGetResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawGetResponse.error)
  return *error_;
}
inline void CmdRawGetResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawGetResponse.error)
}
inline void CmdRawGetResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawGetResponse.error)
}
inline void CmdRawGetResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawGetResponse.error)
}
inline ::std::string* CmdRawGetResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawGetResponse.error)
  return error_;
}
inline ::std::string* CmdRawGetResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawGetResponse::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawGetResponse.error)
}

// optional bytes value = 2;
inline bool CmdRawGetResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdRawGetResponse::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdRawGetResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdRawGetResponse::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CmdRawGetResponse::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawGetResponse.value)
  return *value_;
}
inline void CmdRawGetResponse::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawGetResponse.value)
}
inline void CmdRawGetResponse::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawGetResponse.value)
}
inline void CmdRawGetResponse::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawGetResponse.value)
}
inline ::std::string* CmdRawGetResponse::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawGetResponse.value)
  return value_;
}
inline ::std::string* CmdRawGetResponse::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawGetResponse::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawGetResponse.value)
}

// -------------------------------------------------------------------

// CmdRawPutRequest

// optional bytes key = 1;
inline bool CmdRawPutRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdRawPutRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdRawPutRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdRawPutRequest::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CmdRawPutRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawPutRequest.key)
  return *key_;
}
inline void CmdRawPutRequest::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawPutRequest.key)
}
inline void CmdRawPutRequest::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawPutRequest.key)
}
inline void CmdRawPutRequest::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawPutRequest.key)
}
inline ::std::string* CmdRawPutRequest::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawPutRequest.key)
  return key_;
}
inline ::std::string* CmdRawPutRequest::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawPutRequest::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawPutRequest.key)
}

// optional bytes value = 2;
inline bool CmdRawPutRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CmdRawPutRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CmdRawPutRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CmdRawPutRequest::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& CmdRawPutRequest::value() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawPutRequest.value)
  return *value_;
}
inline void CmdRawPutRequest::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawPutRequest.value)
}
inline void CmdRawPutRequest::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawPutRequest.value)
}
inline void CmdRawPutRequest::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawPutRequest.value)
}
inline ::std::string* CmdRawPutRequest::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawPutRequest.value)
  return value_;
}
inline ::std::string* CmdRawPutRequest::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawPutRequest::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawPutRequest.value)
}

// -------------------------------------------------------------------

// CmdRawPutResponse

// optional string error = 1;
inline bool CmdRawPutResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdRawPutResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdRawPutResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdRawPutResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& CmdRawPutResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawPutResponse.error)
  return *error_;
}
inline void CmdRawPutResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawPutResponse.error)
}
inline void CmdRawPutResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawPutResponse.error)
}
inline void CmdRawPutResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawPutResponse.error)
}
inline ::std::string* CmdRawPutResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawPutResponse.error)
  return error_;
}
inline ::std::string* CmdRawPutResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawPutResponse::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawPutResponse.error)
}

// -------------------------------------------------------------------

// CmdRawDeleteRequest

// optional bytes key = 1;
inline bool CmdRawDeleteRequest::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdRawDeleteRequest::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdRawDeleteRequest::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdRawDeleteRequest::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CmdRawDeleteRequest::key() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawDeleteRequest.key)
  return *key_;
}
inline void CmdRawDeleteRequest::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawDeleteRequest.key)
}
inline void CmdRawDeleteRequest::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawDeleteRequest.key)
}
inline void CmdRawDeleteRequest::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawDeleteRequest.key)
}
inline ::std::string* CmdRawDeleteRequest::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawDeleteRequest.key)
  return key_;
}
inline ::std::string* CmdRawDeleteRequest::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawDeleteRequest::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawDeleteRequest.key)
}

// -------------------------------------------------------------------

// CmdRawDeleteResponse

// optional string error = 1;
inline bool CmdRawDeleteResponse::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CmdRawDeleteResponse::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CmdRawDeleteResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CmdRawDeleteResponse::clear_error() {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& CmdRawDeleteResponse::error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.CmdRawDeleteResponse.error)
  return *error_;
}
inline void CmdRawDeleteResponse::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set:kvrpcpb.CmdRawDeleteResponse.error)
}
inline void CmdRawDeleteResponse::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(value);
  // @@protoc_insertion_point(field_set_char:kvrpcpb.CmdRawDeleteResponse.error)
}
inline void CmdRawDeleteResponse::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:kvrpcpb.CmdRawDeleteResponse.error)
}
inline ::std::string* CmdRawDeleteResponse::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:kvrpcpb.CmdRawDeleteResponse.error)
  return error_;
}
inline ::std::string* CmdRawDeleteResponse::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CmdRawDeleteResponse::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.CmdRawDeleteResponse.error)
}

// -------------------------------------------------------------------

// Request

// optional .kvrpcpb.MessageType type = 1;
inline bool Request::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::kvrpcpb::MessageType Request::type() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.type)
  return static_cast< ::kvrpcpb::MessageType >(type_);
}
inline void Request::set_type(::kvrpcpb::MessageType value) {
  assert(::kvrpcpb::MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Request.type)
}

// optional .kvrpcpb.Context context = 2;
inline bool Request::has_context() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_context() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_context() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_context() {
  if (context_ != NULL) context_->::kvrpcpb::Context::Clear();
  clear_has_context();
}
inline const ::kvrpcpb::Context& Request::context() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.context)
  return context_ != NULL ? *context_ : *default_instance_->context_;
}
inline ::kvrpcpb::Context* Request::mutable_context() {
  set_has_context();
  if (context_ == NULL) context_ = new ::kvrpcpb::Context;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.context)
  return context_;
}
inline ::kvrpcpb::Context* Request::release_context() {
  clear_has_context();
  ::kvrpcpb::Context* temp = context_;
  context_ = NULL;
  return temp;
}
inline void Request::set_allocated_context(::kvrpcpb::Context* context) {
  delete context_;
  context_ = context;
  if (context) {
    set_has_context();
  } else {
    clear_has_context();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.context)
}

// optional .kvrpcpb.CmdGetRequest cmd_get_req = 3;
inline bool Request::has_cmd_get_req() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_cmd_get_req() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_cmd_get_req() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_cmd_get_req() {
  if (cmd_get_req_ != NULL) cmd_get_req_->::kvrpcpb::CmdGetRequest::Clear();
  clear_has_cmd_get_req();
}
inline const ::kvrpcpb::CmdGetRequest& Request::cmd_get_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_get_req)
  return cmd_get_req_ != NULL ? *cmd_get_req_ : *default_instance_->cmd_get_req_;
}
inline ::kvrpcpb::CmdGetRequest* Request::mutable_cmd_get_req() {
  set_has_cmd_get_req();
  if (cmd_get_req_ == NULL) cmd_get_req_ = new ::kvrpcpb::CmdGetRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_get_req)
  return cmd_get_req_;
}
inline ::kvrpcpb::CmdGetRequest* Request::release_cmd_get_req() {
  clear_has_cmd_get_req();
  ::kvrpcpb::CmdGetRequest* temp = cmd_get_req_;
  cmd_get_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_get_req(::kvrpcpb::CmdGetRequest* cmd_get_req) {
  delete cmd_get_req_;
  cmd_get_req_ = cmd_get_req;
  if (cmd_get_req) {
    set_has_cmd_get_req();
  } else {
    clear_has_cmd_get_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_get_req)
}

// optional .kvrpcpb.CmdScanRequest cmd_scan_req = 4;
inline bool Request::has_cmd_scan_req() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_cmd_scan_req() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_cmd_scan_req() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_cmd_scan_req() {
  if (cmd_scan_req_ != NULL) cmd_scan_req_->::kvrpcpb::CmdScanRequest::Clear();
  clear_has_cmd_scan_req();
}
inline const ::kvrpcpb::CmdScanRequest& Request::cmd_scan_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_scan_req)
  return cmd_scan_req_ != NULL ? *cmd_scan_req_ : *default_instance_->cmd_scan_req_;
}
inline ::kvrpcpb::CmdScanRequest* Request::mutable_cmd_scan_req() {
  set_has_cmd_scan_req();
  if (cmd_scan_req_ == NULL) cmd_scan_req_ = new ::kvrpcpb::CmdScanRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_scan_req)
  return cmd_scan_req_;
}
inline ::kvrpcpb::CmdScanRequest* Request::release_cmd_scan_req() {
  clear_has_cmd_scan_req();
  ::kvrpcpb::CmdScanRequest* temp = cmd_scan_req_;
  cmd_scan_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_scan_req(::kvrpcpb::CmdScanRequest* cmd_scan_req) {
  delete cmd_scan_req_;
  cmd_scan_req_ = cmd_scan_req;
  if (cmd_scan_req) {
    set_has_cmd_scan_req();
  } else {
    clear_has_cmd_scan_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_scan_req)
}

// optional .kvrpcpb.CmdPrewriteRequest cmd_prewrite_req = 5;
inline bool Request::has_cmd_prewrite_req() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_cmd_prewrite_req() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_cmd_prewrite_req() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_cmd_prewrite_req() {
  if (cmd_prewrite_req_ != NULL) cmd_prewrite_req_->::kvrpcpb::CmdPrewriteRequest::Clear();
  clear_has_cmd_prewrite_req();
}
inline const ::kvrpcpb::CmdPrewriteRequest& Request::cmd_prewrite_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_prewrite_req)
  return cmd_prewrite_req_ != NULL ? *cmd_prewrite_req_ : *default_instance_->cmd_prewrite_req_;
}
inline ::kvrpcpb::CmdPrewriteRequest* Request::mutable_cmd_prewrite_req() {
  set_has_cmd_prewrite_req();
  if (cmd_prewrite_req_ == NULL) cmd_prewrite_req_ = new ::kvrpcpb::CmdPrewriteRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_prewrite_req)
  return cmd_prewrite_req_;
}
inline ::kvrpcpb::CmdPrewriteRequest* Request::release_cmd_prewrite_req() {
  clear_has_cmd_prewrite_req();
  ::kvrpcpb::CmdPrewriteRequest* temp = cmd_prewrite_req_;
  cmd_prewrite_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_prewrite_req(::kvrpcpb::CmdPrewriteRequest* cmd_prewrite_req) {
  delete cmd_prewrite_req_;
  cmd_prewrite_req_ = cmd_prewrite_req;
  if (cmd_prewrite_req) {
    set_has_cmd_prewrite_req();
  } else {
    clear_has_cmd_prewrite_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_prewrite_req)
}

// optional .kvrpcpb.CmdCommitRequest cmd_commit_req = 6;
inline bool Request::has_cmd_commit_req() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_cmd_commit_req() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_cmd_commit_req() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_cmd_commit_req() {
  if (cmd_commit_req_ != NULL) cmd_commit_req_->::kvrpcpb::CmdCommitRequest::Clear();
  clear_has_cmd_commit_req();
}
inline const ::kvrpcpb::CmdCommitRequest& Request::cmd_commit_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_commit_req)
  return cmd_commit_req_ != NULL ? *cmd_commit_req_ : *default_instance_->cmd_commit_req_;
}
inline ::kvrpcpb::CmdCommitRequest* Request::mutable_cmd_commit_req() {
  set_has_cmd_commit_req();
  if (cmd_commit_req_ == NULL) cmd_commit_req_ = new ::kvrpcpb::CmdCommitRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_commit_req)
  return cmd_commit_req_;
}
inline ::kvrpcpb::CmdCommitRequest* Request::release_cmd_commit_req() {
  clear_has_cmd_commit_req();
  ::kvrpcpb::CmdCommitRequest* temp = cmd_commit_req_;
  cmd_commit_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_commit_req(::kvrpcpb::CmdCommitRequest* cmd_commit_req) {
  delete cmd_commit_req_;
  cmd_commit_req_ = cmd_commit_req;
  if (cmd_commit_req) {
    set_has_cmd_commit_req();
  } else {
    clear_has_cmd_commit_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_commit_req)
}

// optional .kvrpcpb.CmdCleanupRequest cmd_cleanup_req = 7;
inline bool Request::has_cmd_cleanup_req() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_cmd_cleanup_req() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_cmd_cleanup_req() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_cmd_cleanup_req() {
  if (cmd_cleanup_req_ != NULL) cmd_cleanup_req_->::kvrpcpb::CmdCleanupRequest::Clear();
  clear_has_cmd_cleanup_req();
}
inline const ::kvrpcpb::CmdCleanupRequest& Request::cmd_cleanup_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_cleanup_req)
  return cmd_cleanup_req_ != NULL ? *cmd_cleanup_req_ : *default_instance_->cmd_cleanup_req_;
}
inline ::kvrpcpb::CmdCleanupRequest* Request::mutable_cmd_cleanup_req() {
  set_has_cmd_cleanup_req();
  if (cmd_cleanup_req_ == NULL) cmd_cleanup_req_ = new ::kvrpcpb::CmdCleanupRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_cleanup_req)
  return cmd_cleanup_req_;
}
inline ::kvrpcpb::CmdCleanupRequest* Request::release_cmd_cleanup_req() {
  clear_has_cmd_cleanup_req();
  ::kvrpcpb::CmdCleanupRequest* temp = cmd_cleanup_req_;
  cmd_cleanup_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_cleanup_req(::kvrpcpb::CmdCleanupRequest* cmd_cleanup_req) {
  delete cmd_cleanup_req_;
  cmd_cleanup_req_ = cmd_cleanup_req;
  if (cmd_cleanup_req) {
    set_has_cmd_cleanup_req();
  } else {
    clear_has_cmd_cleanup_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_cleanup_req)
}

// optional .kvrpcpb.CmdBatchGetRequest cmd_batch_get_req = 10;
inline bool Request::has_cmd_batch_get_req() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_cmd_batch_get_req() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_cmd_batch_get_req() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_cmd_batch_get_req() {
  if (cmd_batch_get_req_ != NULL) cmd_batch_get_req_->::kvrpcpb::CmdBatchGetRequest::Clear();
  clear_has_cmd_batch_get_req();
}
inline const ::kvrpcpb::CmdBatchGetRequest& Request::cmd_batch_get_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_batch_get_req)
  return cmd_batch_get_req_ != NULL ? *cmd_batch_get_req_ : *default_instance_->cmd_batch_get_req_;
}
inline ::kvrpcpb::CmdBatchGetRequest* Request::mutable_cmd_batch_get_req() {
  set_has_cmd_batch_get_req();
  if (cmd_batch_get_req_ == NULL) cmd_batch_get_req_ = new ::kvrpcpb::CmdBatchGetRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_batch_get_req)
  return cmd_batch_get_req_;
}
inline ::kvrpcpb::CmdBatchGetRequest* Request::release_cmd_batch_get_req() {
  clear_has_cmd_batch_get_req();
  ::kvrpcpb::CmdBatchGetRequest* temp = cmd_batch_get_req_;
  cmd_batch_get_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_batch_get_req(::kvrpcpb::CmdBatchGetRequest* cmd_batch_get_req) {
  delete cmd_batch_get_req_;
  cmd_batch_get_req_ = cmd_batch_get_req;
  if (cmd_batch_get_req) {
    set_has_cmd_batch_get_req();
  } else {
    clear_has_cmd_batch_get_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_batch_get_req)
}

// optional .kvrpcpb.CmdBatchRollbackRequest cmd_batch_rollback_req = 11;
inline bool Request::has_cmd_batch_rollback_req() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_cmd_batch_rollback_req() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_cmd_batch_rollback_req() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_cmd_batch_rollback_req() {
  if (cmd_batch_rollback_req_ != NULL) cmd_batch_rollback_req_->::kvrpcpb::CmdBatchRollbackRequest::Clear();
  clear_has_cmd_batch_rollback_req();
}
inline const ::kvrpcpb::CmdBatchRollbackRequest& Request::cmd_batch_rollback_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_batch_rollback_req)
  return cmd_batch_rollback_req_ != NULL ? *cmd_batch_rollback_req_ : *default_instance_->cmd_batch_rollback_req_;
}
inline ::kvrpcpb::CmdBatchRollbackRequest* Request::mutable_cmd_batch_rollback_req() {
  set_has_cmd_batch_rollback_req();
  if (cmd_batch_rollback_req_ == NULL) cmd_batch_rollback_req_ = new ::kvrpcpb::CmdBatchRollbackRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_batch_rollback_req)
  return cmd_batch_rollback_req_;
}
inline ::kvrpcpb::CmdBatchRollbackRequest* Request::release_cmd_batch_rollback_req() {
  clear_has_cmd_batch_rollback_req();
  ::kvrpcpb::CmdBatchRollbackRequest* temp = cmd_batch_rollback_req_;
  cmd_batch_rollback_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_batch_rollback_req(::kvrpcpb::CmdBatchRollbackRequest* cmd_batch_rollback_req) {
  delete cmd_batch_rollback_req_;
  cmd_batch_rollback_req_ = cmd_batch_rollback_req;
  if (cmd_batch_rollback_req) {
    set_has_cmd_batch_rollback_req();
  } else {
    clear_has_cmd_batch_rollback_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_batch_rollback_req)
}

// optional .kvrpcpb.CmdScanLockRequest cmd_scan_lock_req = 12;
inline bool Request::has_cmd_scan_lock_req() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_cmd_scan_lock_req() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_cmd_scan_lock_req() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_cmd_scan_lock_req() {
  if (cmd_scan_lock_req_ != NULL) cmd_scan_lock_req_->::kvrpcpb::CmdScanLockRequest::Clear();
  clear_has_cmd_scan_lock_req();
}
inline const ::kvrpcpb::CmdScanLockRequest& Request::cmd_scan_lock_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_scan_lock_req)
  return cmd_scan_lock_req_ != NULL ? *cmd_scan_lock_req_ : *default_instance_->cmd_scan_lock_req_;
}
inline ::kvrpcpb::CmdScanLockRequest* Request::mutable_cmd_scan_lock_req() {
  set_has_cmd_scan_lock_req();
  if (cmd_scan_lock_req_ == NULL) cmd_scan_lock_req_ = new ::kvrpcpb::CmdScanLockRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_scan_lock_req)
  return cmd_scan_lock_req_;
}
inline ::kvrpcpb::CmdScanLockRequest* Request::release_cmd_scan_lock_req() {
  clear_has_cmd_scan_lock_req();
  ::kvrpcpb::CmdScanLockRequest* temp = cmd_scan_lock_req_;
  cmd_scan_lock_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_scan_lock_req(::kvrpcpb::CmdScanLockRequest* cmd_scan_lock_req) {
  delete cmd_scan_lock_req_;
  cmd_scan_lock_req_ = cmd_scan_lock_req;
  if (cmd_scan_lock_req) {
    set_has_cmd_scan_lock_req();
  } else {
    clear_has_cmd_scan_lock_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_scan_lock_req)
}

// optional .kvrpcpb.CmdResolveLockRequest cmd_resolve_lock_req = 13;
inline bool Request::has_cmd_resolve_lock_req() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_cmd_resolve_lock_req() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_cmd_resolve_lock_req() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_cmd_resolve_lock_req() {
  if (cmd_resolve_lock_req_ != NULL) cmd_resolve_lock_req_->::kvrpcpb::CmdResolveLockRequest::Clear();
  clear_has_cmd_resolve_lock_req();
}
inline const ::kvrpcpb::CmdResolveLockRequest& Request::cmd_resolve_lock_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_resolve_lock_req)
  return cmd_resolve_lock_req_ != NULL ? *cmd_resolve_lock_req_ : *default_instance_->cmd_resolve_lock_req_;
}
inline ::kvrpcpb::CmdResolveLockRequest* Request::mutable_cmd_resolve_lock_req() {
  set_has_cmd_resolve_lock_req();
  if (cmd_resolve_lock_req_ == NULL) cmd_resolve_lock_req_ = new ::kvrpcpb::CmdResolveLockRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_resolve_lock_req)
  return cmd_resolve_lock_req_;
}
inline ::kvrpcpb::CmdResolveLockRequest* Request::release_cmd_resolve_lock_req() {
  clear_has_cmd_resolve_lock_req();
  ::kvrpcpb::CmdResolveLockRequest* temp = cmd_resolve_lock_req_;
  cmd_resolve_lock_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_resolve_lock_req(::kvrpcpb::CmdResolveLockRequest* cmd_resolve_lock_req) {
  delete cmd_resolve_lock_req_;
  cmd_resolve_lock_req_ = cmd_resolve_lock_req;
  if (cmd_resolve_lock_req) {
    set_has_cmd_resolve_lock_req();
  } else {
    clear_has_cmd_resolve_lock_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_resolve_lock_req)
}

// optional .kvrpcpb.CmdGCRequest cmd_gc_req = 14;
inline bool Request::has_cmd_gc_req() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_cmd_gc_req() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_cmd_gc_req() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_cmd_gc_req() {
  if (cmd_gc_req_ != NULL) cmd_gc_req_->::kvrpcpb::CmdGCRequest::Clear();
  clear_has_cmd_gc_req();
}
inline const ::kvrpcpb::CmdGCRequest& Request::cmd_gc_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_gc_req)
  return cmd_gc_req_ != NULL ? *cmd_gc_req_ : *default_instance_->cmd_gc_req_;
}
inline ::kvrpcpb::CmdGCRequest* Request::mutable_cmd_gc_req() {
  set_has_cmd_gc_req();
  if (cmd_gc_req_ == NULL) cmd_gc_req_ = new ::kvrpcpb::CmdGCRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_gc_req)
  return cmd_gc_req_;
}
inline ::kvrpcpb::CmdGCRequest* Request::release_cmd_gc_req() {
  clear_has_cmd_gc_req();
  ::kvrpcpb::CmdGCRequest* temp = cmd_gc_req_;
  cmd_gc_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_gc_req(::kvrpcpb::CmdGCRequest* cmd_gc_req) {
  delete cmd_gc_req_;
  cmd_gc_req_ = cmd_gc_req;
  if (cmd_gc_req) {
    set_has_cmd_gc_req();
  } else {
    clear_has_cmd_gc_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_gc_req)
}

// optional .kvrpcpb.CmdRawGetRequest cmd_raw_get_req = 256;
inline bool Request::has_cmd_raw_get_req() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_cmd_raw_get_req() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_cmd_raw_get_req() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_cmd_raw_get_req() {
  if (cmd_raw_get_req_ != NULL) cmd_raw_get_req_->::kvrpcpb::CmdRawGetRequest::Clear();
  clear_has_cmd_raw_get_req();
}
inline const ::kvrpcpb::CmdRawGetRequest& Request::cmd_raw_get_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_raw_get_req)
  return cmd_raw_get_req_ != NULL ? *cmd_raw_get_req_ : *default_instance_->cmd_raw_get_req_;
}
inline ::kvrpcpb::CmdRawGetRequest* Request::mutable_cmd_raw_get_req() {
  set_has_cmd_raw_get_req();
  if (cmd_raw_get_req_ == NULL) cmd_raw_get_req_ = new ::kvrpcpb::CmdRawGetRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_raw_get_req)
  return cmd_raw_get_req_;
}
inline ::kvrpcpb::CmdRawGetRequest* Request::release_cmd_raw_get_req() {
  clear_has_cmd_raw_get_req();
  ::kvrpcpb::CmdRawGetRequest* temp = cmd_raw_get_req_;
  cmd_raw_get_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_raw_get_req(::kvrpcpb::CmdRawGetRequest* cmd_raw_get_req) {
  delete cmd_raw_get_req_;
  cmd_raw_get_req_ = cmd_raw_get_req;
  if (cmd_raw_get_req) {
    set_has_cmd_raw_get_req();
  } else {
    clear_has_cmd_raw_get_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_raw_get_req)
}

// optional .kvrpcpb.CmdRawPutRequest cmd_raw_put_req = 257;
inline bool Request::has_cmd_raw_put_req() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Request::set_has_cmd_raw_put_req() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Request::clear_has_cmd_raw_put_req() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Request::clear_cmd_raw_put_req() {
  if (cmd_raw_put_req_ != NULL) cmd_raw_put_req_->::kvrpcpb::CmdRawPutRequest::Clear();
  clear_has_cmd_raw_put_req();
}
inline const ::kvrpcpb::CmdRawPutRequest& Request::cmd_raw_put_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_raw_put_req)
  return cmd_raw_put_req_ != NULL ? *cmd_raw_put_req_ : *default_instance_->cmd_raw_put_req_;
}
inline ::kvrpcpb::CmdRawPutRequest* Request::mutable_cmd_raw_put_req() {
  set_has_cmd_raw_put_req();
  if (cmd_raw_put_req_ == NULL) cmd_raw_put_req_ = new ::kvrpcpb::CmdRawPutRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_raw_put_req)
  return cmd_raw_put_req_;
}
inline ::kvrpcpb::CmdRawPutRequest* Request::release_cmd_raw_put_req() {
  clear_has_cmd_raw_put_req();
  ::kvrpcpb::CmdRawPutRequest* temp = cmd_raw_put_req_;
  cmd_raw_put_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_raw_put_req(::kvrpcpb::CmdRawPutRequest* cmd_raw_put_req) {
  delete cmd_raw_put_req_;
  cmd_raw_put_req_ = cmd_raw_put_req;
  if (cmd_raw_put_req) {
    set_has_cmd_raw_put_req();
  } else {
    clear_has_cmd_raw_put_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_raw_put_req)
}

// optional .kvrpcpb.CmdRawDeleteRequest cmd_raw_delete_req = 258;
inline bool Request::has_cmd_raw_delete_req() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Request::set_has_cmd_raw_delete_req() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Request::clear_has_cmd_raw_delete_req() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Request::clear_cmd_raw_delete_req() {
  if (cmd_raw_delete_req_ != NULL) cmd_raw_delete_req_->::kvrpcpb::CmdRawDeleteRequest::Clear();
  clear_has_cmd_raw_delete_req();
}
inline const ::kvrpcpb::CmdRawDeleteRequest& Request::cmd_raw_delete_req() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Request.cmd_raw_delete_req)
  return cmd_raw_delete_req_ != NULL ? *cmd_raw_delete_req_ : *default_instance_->cmd_raw_delete_req_;
}
inline ::kvrpcpb::CmdRawDeleteRequest* Request::mutable_cmd_raw_delete_req() {
  set_has_cmd_raw_delete_req();
  if (cmd_raw_delete_req_ == NULL) cmd_raw_delete_req_ = new ::kvrpcpb::CmdRawDeleteRequest;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Request.cmd_raw_delete_req)
  return cmd_raw_delete_req_;
}
inline ::kvrpcpb::CmdRawDeleteRequest* Request::release_cmd_raw_delete_req() {
  clear_has_cmd_raw_delete_req();
  ::kvrpcpb::CmdRawDeleteRequest* temp = cmd_raw_delete_req_;
  cmd_raw_delete_req_ = NULL;
  return temp;
}
inline void Request::set_allocated_cmd_raw_delete_req(::kvrpcpb::CmdRawDeleteRequest* cmd_raw_delete_req) {
  delete cmd_raw_delete_req_;
  cmd_raw_delete_req_ = cmd_raw_delete_req;
  if (cmd_raw_delete_req) {
    set_has_cmd_raw_delete_req();
  } else {
    clear_has_cmd_raw_delete_req();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Request.cmd_raw_delete_req)
}

// -------------------------------------------------------------------

// Response

// optional .kvrpcpb.MessageType type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::kvrpcpb::MessageType Response::type() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.type)
  return static_cast< ::kvrpcpb::MessageType >(type_);
}
inline void Response::set_type(::kvrpcpb::MessageType value) {
  assert(::kvrpcpb::MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:kvrpcpb.Response.type)
}

// optional .errorpb.Error region_error = 2;
inline bool Response::has_region_error() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_region_error() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_region_error() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_region_error() {
  if (region_error_ != NULL) region_error_->::errorpb::Error::Clear();
  clear_has_region_error();
}
inline const ::errorpb::Error& Response::region_error() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.region_error)
  return region_error_ != NULL ? *region_error_ : *default_instance_->region_error_;
}
inline ::errorpb::Error* Response::mutable_region_error() {
  set_has_region_error();
  if (region_error_ == NULL) region_error_ = new ::errorpb::Error;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.region_error)
  return region_error_;
}
inline ::errorpb::Error* Response::release_region_error() {
  clear_has_region_error();
  ::errorpb::Error* temp = region_error_;
  region_error_ = NULL;
  return temp;
}
inline void Response::set_allocated_region_error(::errorpb::Error* region_error) {
  delete region_error_;
  region_error_ = region_error;
  if (region_error) {
    set_has_region_error();
  } else {
    clear_has_region_error();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.region_error)
}

// optional .kvrpcpb.CmdGetResponse cmd_get_resp = 3;
inline bool Response::has_cmd_get_resp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_cmd_get_resp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_cmd_get_resp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_cmd_get_resp() {
  if (cmd_get_resp_ != NULL) cmd_get_resp_->::kvrpcpb::CmdGetResponse::Clear();
  clear_has_cmd_get_resp();
}
inline const ::kvrpcpb::CmdGetResponse& Response::cmd_get_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_get_resp)
  return cmd_get_resp_ != NULL ? *cmd_get_resp_ : *default_instance_->cmd_get_resp_;
}
inline ::kvrpcpb::CmdGetResponse* Response::mutable_cmd_get_resp() {
  set_has_cmd_get_resp();
  if (cmd_get_resp_ == NULL) cmd_get_resp_ = new ::kvrpcpb::CmdGetResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_get_resp)
  return cmd_get_resp_;
}
inline ::kvrpcpb::CmdGetResponse* Response::release_cmd_get_resp() {
  clear_has_cmd_get_resp();
  ::kvrpcpb::CmdGetResponse* temp = cmd_get_resp_;
  cmd_get_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_get_resp(::kvrpcpb::CmdGetResponse* cmd_get_resp) {
  delete cmd_get_resp_;
  cmd_get_resp_ = cmd_get_resp;
  if (cmd_get_resp) {
    set_has_cmd_get_resp();
  } else {
    clear_has_cmd_get_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_get_resp)
}

// optional .kvrpcpb.CmdScanResponse cmd_scan_resp = 4;
inline bool Response::has_cmd_scan_resp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_cmd_scan_resp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_cmd_scan_resp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_cmd_scan_resp() {
  if (cmd_scan_resp_ != NULL) cmd_scan_resp_->::kvrpcpb::CmdScanResponse::Clear();
  clear_has_cmd_scan_resp();
}
inline const ::kvrpcpb::CmdScanResponse& Response::cmd_scan_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_scan_resp)
  return cmd_scan_resp_ != NULL ? *cmd_scan_resp_ : *default_instance_->cmd_scan_resp_;
}
inline ::kvrpcpb::CmdScanResponse* Response::mutable_cmd_scan_resp() {
  set_has_cmd_scan_resp();
  if (cmd_scan_resp_ == NULL) cmd_scan_resp_ = new ::kvrpcpb::CmdScanResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_scan_resp)
  return cmd_scan_resp_;
}
inline ::kvrpcpb::CmdScanResponse* Response::release_cmd_scan_resp() {
  clear_has_cmd_scan_resp();
  ::kvrpcpb::CmdScanResponse* temp = cmd_scan_resp_;
  cmd_scan_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_scan_resp(::kvrpcpb::CmdScanResponse* cmd_scan_resp) {
  delete cmd_scan_resp_;
  cmd_scan_resp_ = cmd_scan_resp;
  if (cmd_scan_resp) {
    set_has_cmd_scan_resp();
  } else {
    clear_has_cmd_scan_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_scan_resp)
}

// optional .kvrpcpb.CmdPrewriteResponse cmd_prewrite_resp = 5;
inline bool Response::has_cmd_prewrite_resp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_cmd_prewrite_resp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_cmd_prewrite_resp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_cmd_prewrite_resp() {
  if (cmd_prewrite_resp_ != NULL) cmd_prewrite_resp_->::kvrpcpb::CmdPrewriteResponse::Clear();
  clear_has_cmd_prewrite_resp();
}
inline const ::kvrpcpb::CmdPrewriteResponse& Response::cmd_prewrite_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_prewrite_resp)
  return cmd_prewrite_resp_ != NULL ? *cmd_prewrite_resp_ : *default_instance_->cmd_prewrite_resp_;
}
inline ::kvrpcpb::CmdPrewriteResponse* Response::mutable_cmd_prewrite_resp() {
  set_has_cmd_prewrite_resp();
  if (cmd_prewrite_resp_ == NULL) cmd_prewrite_resp_ = new ::kvrpcpb::CmdPrewriteResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_prewrite_resp)
  return cmd_prewrite_resp_;
}
inline ::kvrpcpb::CmdPrewriteResponse* Response::release_cmd_prewrite_resp() {
  clear_has_cmd_prewrite_resp();
  ::kvrpcpb::CmdPrewriteResponse* temp = cmd_prewrite_resp_;
  cmd_prewrite_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_prewrite_resp(::kvrpcpb::CmdPrewriteResponse* cmd_prewrite_resp) {
  delete cmd_prewrite_resp_;
  cmd_prewrite_resp_ = cmd_prewrite_resp;
  if (cmd_prewrite_resp) {
    set_has_cmd_prewrite_resp();
  } else {
    clear_has_cmd_prewrite_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_prewrite_resp)
}

// optional .kvrpcpb.CmdCommitResponse cmd_commit_resp = 6;
inline bool Response::has_cmd_commit_resp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_cmd_commit_resp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_cmd_commit_resp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_cmd_commit_resp() {
  if (cmd_commit_resp_ != NULL) cmd_commit_resp_->::kvrpcpb::CmdCommitResponse::Clear();
  clear_has_cmd_commit_resp();
}
inline const ::kvrpcpb::CmdCommitResponse& Response::cmd_commit_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_commit_resp)
  return cmd_commit_resp_ != NULL ? *cmd_commit_resp_ : *default_instance_->cmd_commit_resp_;
}
inline ::kvrpcpb::CmdCommitResponse* Response::mutable_cmd_commit_resp() {
  set_has_cmd_commit_resp();
  if (cmd_commit_resp_ == NULL) cmd_commit_resp_ = new ::kvrpcpb::CmdCommitResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_commit_resp)
  return cmd_commit_resp_;
}
inline ::kvrpcpb::CmdCommitResponse* Response::release_cmd_commit_resp() {
  clear_has_cmd_commit_resp();
  ::kvrpcpb::CmdCommitResponse* temp = cmd_commit_resp_;
  cmd_commit_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_commit_resp(::kvrpcpb::CmdCommitResponse* cmd_commit_resp) {
  delete cmd_commit_resp_;
  cmd_commit_resp_ = cmd_commit_resp;
  if (cmd_commit_resp) {
    set_has_cmd_commit_resp();
  } else {
    clear_has_cmd_commit_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_commit_resp)
}

// optional .kvrpcpb.CmdCleanupResponse cmd_cleanup_resp = 7;
inline bool Response::has_cmd_cleanup_resp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_cmd_cleanup_resp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_cmd_cleanup_resp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_cmd_cleanup_resp() {
  if (cmd_cleanup_resp_ != NULL) cmd_cleanup_resp_->::kvrpcpb::CmdCleanupResponse::Clear();
  clear_has_cmd_cleanup_resp();
}
inline const ::kvrpcpb::CmdCleanupResponse& Response::cmd_cleanup_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_cleanup_resp)
  return cmd_cleanup_resp_ != NULL ? *cmd_cleanup_resp_ : *default_instance_->cmd_cleanup_resp_;
}
inline ::kvrpcpb::CmdCleanupResponse* Response::mutable_cmd_cleanup_resp() {
  set_has_cmd_cleanup_resp();
  if (cmd_cleanup_resp_ == NULL) cmd_cleanup_resp_ = new ::kvrpcpb::CmdCleanupResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_cleanup_resp)
  return cmd_cleanup_resp_;
}
inline ::kvrpcpb::CmdCleanupResponse* Response::release_cmd_cleanup_resp() {
  clear_has_cmd_cleanup_resp();
  ::kvrpcpb::CmdCleanupResponse* temp = cmd_cleanup_resp_;
  cmd_cleanup_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_cleanup_resp(::kvrpcpb::CmdCleanupResponse* cmd_cleanup_resp) {
  delete cmd_cleanup_resp_;
  cmd_cleanup_resp_ = cmd_cleanup_resp;
  if (cmd_cleanup_resp) {
    set_has_cmd_cleanup_resp();
  } else {
    clear_has_cmd_cleanup_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_cleanup_resp)
}

// optional .kvrpcpb.CmdBatchGetResponse cmd_batch_get_resp = 10;
inline bool Response::has_cmd_batch_get_resp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_cmd_batch_get_resp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_cmd_batch_get_resp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_cmd_batch_get_resp() {
  if (cmd_batch_get_resp_ != NULL) cmd_batch_get_resp_->::kvrpcpb::CmdBatchGetResponse::Clear();
  clear_has_cmd_batch_get_resp();
}
inline const ::kvrpcpb::CmdBatchGetResponse& Response::cmd_batch_get_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_batch_get_resp)
  return cmd_batch_get_resp_ != NULL ? *cmd_batch_get_resp_ : *default_instance_->cmd_batch_get_resp_;
}
inline ::kvrpcpb::CmdBatchGetResponse* Response::mutable_cmd_batch_get_resp() {
  set_has_cmd_batch_get_resp();
  if (cmd_batch_get_resp_ == NULL) cmd_batch_get_resp_ = new ::kvrpcpb::CmdBatchGetResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_batch_get_resp)
  return cmd_batch_get_resp_;
}
inline ::kvrpcpb::CmdBatchGetResponse* Response::release_cmd_batch_get_resp() {
  clear_has_cmd_batch_get_resp();
  ::kvrpcpb::CmdBatchGetResponse* temp = cmd_batch_get_resp_;
  cmd_batch_get_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_batch_get_resp(::kvrpcpb::CmdBatchGetResponse* cmd_batch_get_resp) {
  delete cmd_batch_get_resp_;
  cmd_batch_get_resp_ = cmd_batch_get_resp;
  if (cmd_batch_get_resp) {
    set_has_cmd_batch_get_resp();
  } else {
    clear_has_cmd_batch_get_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_batch_get_resp)
}

// optional .kvrpcpb.CmdBatchRollbackResponse cmd_batch_rollback_resp = 11;
inline bool Response::has_cmd_batch_rollback_resp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_cmd_batch_rollback_resp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_cmd_batch_rollback_resp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_cmd_batch_rollback_resp() {
  if (cmd_batch_rollback_resp_ != NULL) cmd_batch_rollback_resp_->::kvrpcpb::CmdBatchRollbackResponse::Clear();
  clear_has_cmd_batch_rollback_resp();
}
inline const ::kvrpcpb::CmdBatchRollbackResponse& Response::cmd_batch_rollback_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_batch_rollback_resp)
  return cmd_batch_rollback_resp_ != NULL ? *cmd_batch_rollback_resp_ : *default_instance_->cmd_batch_rollback_resp_;
}
inline ::kvrpcpb::CmdBatchRollbackResponse* Response::mutable_cmd_batch_rollback_resp() {
  set_has_cmd_batch_rollback_resp();
  if (cmd_batch_rollback_resp_ == NULL) cmd_batch_rollback_resp_ = new ::kvrpcpb::CmdBatchRollbackResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_batch_rollback_resp)
  return cmd_batch_rollback_resp_;
}
inline ::kvrpcpb::CmdBatchRollbackResponse* Response::release_cmd_batch_rollback_resp() {
  clear_has_cmd_batch_rollback_resp();
  ::kvrpcpb::CmdBatchRollbackResponse* temp = cmd_batch_rollback_resp_;
  cmd_batch_rollback_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_batch_rollback_resp(::kvrpcpb::CmdBatchRollbackResponse* cmd_batch_rollback_resp) {
  delete cmd_batch_rollback_resp_;
  cmd_batch_rollback_resp_ = cmd_batch_rollback_resp;
  if (cmd_batch_rollback_resp) {
    set_has_cmd_batch_rollback_resp();
  } else {
    clear_has_cmd_batch_rollback_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_batch_rollback_resp)
}

// optional .kvrpcpb.CmdScanLockResponse cmd_scan_lock_resp = 12;
inline bool Response::has_cmd_scan_lock_resp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_cmd_scan_lock_resp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_cmd_scan_lock_resp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_cmd_scan_lock_resp() {
  if (cmd_scan_lock_resp_ != NULL) cmd_scan_lock_resp_->::kvrpcpb::CmdScanLockResponse::Clear();
  clear_has_cmd_scan_lock_resp();
}
inline const ::kvrpcpb::CmdScanLockResponse& Response::cmd_scan_lock_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_scan_lock_resp)
  return cmd_scan_lock_resp_ != NULL ? *cmd_scan_lock_resp_ : *default_instance_->cmd_scan_lock_resp_;
}
inline ::kvrpcpb::CmdScanLockResponse* Response::mutable_cmd_scan_lock_resp() {
  set_has_cmd_scan_lock_resp();
  if (cmd_scan_lock_resp_ == NULL) cmd_scan_lock_resp_ = new ::kvrpcpb::CmdScanLockResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_scan_lock_resp)
  return cmd_scan_lock_resp_;
}
inline ::kvrpcpb::CmdScanLockResponse* Response::release_cmd_scan_lock_resp() {
  clear_has_cmd_scan_lock_resp();
  ::kvrpcpb::CmdScanLockResponse* temp = cmd_scan_lock_resp_;
  cmd_scan_lock_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_scan_lock_resp(::kvrpcpb::CmdScanLockResponse* cmd_scan_lock_resp) {
  delete cmd_scan_lock_resp_;
  cmd_scan_lock_resp_ = cmd_scan_lock_resp;
  if (cmd_scan_lock_resp) {
    set_has_cmd_scan_lock_resp();
  } else {
    clear_has_cmd_scan_lock_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_scan_lock_resp)
}

// optional .kvrpcpb.CmdResolveLockResponse cmd_resolve_lock_resp = 13;
inline bool Response::has_cmd_resolve_lock_resp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Response::set_has_cmd_resolve_lock_resp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Response::clear_has_cmd_resolve_lock_resp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Response::clear_cmd_resolve_lock_resp() {
  if (cmd_resolve_lock_resp_ != NULL) cmd_resolve_lock_resp_->::kvrpcpb::CmdResolveLockResponse::Clear();
  clear_has_cmd_resolve_lock_resp();
}
inline const ::kvrpcpb::CmdResolveLockResponse& Response::cmd_resolve_lock_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_resolve_lock_resp)
  return cmd_resolve_lock_resp_ != NULL ? *cmd_resolve_lock_resp_ : *default_instance_->cmd_resolve_lock_resp_;
}
inline ::kvrpcpb::CmdResolveLockResponse* Response::mutable_cmd_resolve_lock_resp() {
  set_has_cmd_resolve_lock_resp();
  if (cmd_resolve_lock_resp_ == NULL) cmd_resolve_lock_resp_ = new ::kvrpcpb::CmdResolveLockResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_resolve_lock_resp)
  return cmd_resolve_lock_resp_;
}
inline ::kvrpcpb::CmdResolveLockResponse* Response::release_cmd_resolve_lock_resp() {
  clear_has_cmd_resolve_lock_resp();
  ::kvrpcpb::CmdResolveLockResponse* temp = cmd_resolve_lock_resp_;
  cmd_resolve_lock_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_resolve_lock_resp(::kvrpcpb::CmdResolveLockResponse* cmd_resolve_lock_resp) {
  delete cmd_resolve_lock_resp_;
  cmd_resolve_lock_resp_ = cmd_resolve_lock_resp;
  if (cmd_resolve_lock_resp) {
    set_has_cmd_resolve_lock_resp();
  } else {
    clear_has_cmd_resolve_lock_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_resolve_lock_resp)
}

// optional .kvrpcpb.CmdGCResponse cmd_gc_resp = 14;
inline bool Response::has_cmd_gc_resp() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Response::set_has_cmd_gc_resp() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Response::clear_has_cmd_gc_resp() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Response::clear_cmd_gc_resp() {
  if (cmd_gc_resp_ != NULL) cmd_gc_resp_->::kvrpcpb::CmdGCResponse::Clear();
  clear_has_cmd_gc_resp();
}
inline const ::kvrpcpb::CmdGCResponse& Response::cmd_gc_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_gc_resp)
  return cmd_gc_resp_ != NULL ? *cmd_gc_resp_ : *default_instance_->cmd_gc_resp_;
}
inline ::kvrpcpb::CmdGCResponse* Response::mutable_cmd_gc_resp() {
  set_has_cmd_gc_resp();
  if (cmd_gc_resp_ == NULL) cmd_gc_resp_ = new ::kvrpcpb::CmdGCResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_gc_resp)
  return cmd_gc_resp_;
}
inline ::kvrpcpb::CmdGCResponse* Response::release_cmd_gc_resp() {
  clear_has_cmd_gc_resp();
  ::kvrpcpb::CmdGCResponse* temp = cmd_gc_resp_;
  cmd_gc_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_gc_resp(::kvrpcpb::CmdGCResponse* cmd_gc_resp) {
  delete cmd_gc_resp_;
  cmd_gc_resp_ = cmd_gc_resp;
  if (cmd_gc_resp) {
    set_has_cmd_gc_resp();
  } else {
    clear_has_cmd_gc_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_gc_resp)
}

// optional .kvrpcpb.CmdRawGetResponse cmd_raw_get_resp = 256;
inline bool Response::has_cmd_raw_get_resp() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Response::set_has_cmd_raw_get_resp() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Response::clear_has_cmd_raw_get_resp() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Response::clear_cmd_raw_get_resp() {
  if (cmd_raw_get_resp_ != NULL) cmd_raw_get_resp_->::kvrpcpb::CmdRawGetResponse::Clear();
  clear_has_cmd_raw_get_resp();
}
inline const ::kvrpcpb::CmdRawGetResponse& Response::cmd_raw_get_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_raw_get_resp)
  return cmd_raw_get_resp_ != NULL ? *cmd_raw_get_resp_ : *default_instance_->cmd_raw_get_resp_;
}
inline ::kvrpcpb::CmdRawGetResponse* Response::mutable_cmd_raw_get_resp() {
  set_has_cmd_raw_get_resp();
  if (cmd_raw_get_resp_ == NULL) cmd_raw_get_resp_ = new ::kvrpcpb::CmdRawGetResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_raw_get_resp)
  return cmd_raw_get_resp_;
}
inline ::kvrpcpb::CmdRawGetResponse* Response::release_cmd_raw_get_resp() {
  clear_has_cmd_raw_get_resp();
  ::kvrpcpb::CmdRawGetResponse* temp = cmd_raw_get_resp_;
  cmd_raw_get_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_raw_get_resp(::kvrpcpb::CmdRawGetResponse* cmd_raw_get_resp) {
  delete cmd_raw_get_resp_;
  cmd_raw_get_resp_ = cmd_raw_get_resp;
  if (cmd_raw_get_resp) {
    set_has_cmd_raw_get_resp();
  } else {
    clear_has_cmd_raw_get_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_raw_get_resp)
}

// optional .kvrpcpb.CmdRawPutResponse cmd_raw_put_resp = 257;
inline bool Response::has_cmd_raw_put_resp() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Response::set_has_cmd_raw_put_resp() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Response::clear_has_cmd_raw_put_resp() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Response::clear_cmd_raw_put_resp() {
  if (cmd_raw_put_resp_ != NULL) cmd_raw_put_resp_->::kvrpcpb::CmdRawPutResponse::Clear();
  clear_has_cmd_raw_put_resp();
}
inline const ::kvrpcpb::CmdRawPutResponse& Response::cmd_raw_put_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_raw_put_resp)
  return cmd_raw_put_resp_ != NULL ? *cmd_raw_put_resp_ : *default_instance_->cmd_raw_put_resp_;
}
inline ::kvrpcpb::CmdRawPutResponse* Response::mutable_cmd_raw_put_resp() {
  set_has_cmd_raw_put_resp();
  if (cmd_raw_put_resp_ == NULL) cmd_raw_put_resp_ = new ::kvrpcpb::CmdRawPutResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_raw_put_resp)
  return cmd_raw_put_resp_;
}
inline ::kvrpcpb::CmdRawPutResponse* Response::release_cmd_raw_put_resp() {
  clear_has_cmd_raw_put_resp();
  ::kvrpcpb::CmdRawPutResponse* temp = cmd_raw_put_resp_;
  cmd_raw_put_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_raw_put_resp(::kvrpcpb::CmdRawPutResponse* cmd_raw_put_resp) {
  delete cmd_raw_put_resp_;
  cmd_raw_put_resp_ = cmd_raw_put_resp;
  if (cmd_raw_put_resp) {
    set_has_cmd_raw_put_resp();
  } else {
    clear_has_cmd_raw_put_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_raw_put_resp)
}

// optional .kvrpcpb.CmdRawDeleteResponse cmd_raw_delete_resp = 258;
inline bool Response::has_cmd_raw_delete_resp() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Response::set_has_cmd_raw_delete_resp() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Response::clear_has_cmd_raw_delete_resp() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Response::clear_cmd_raw_delete_resp() {
  if (cmd_raw_delete_resp_ != NULL) cmd_raw_delete_resp_->::kvrpcpb::CmdRawDeleteResponse::Clear();
  clear_has_cmd_raw_delete_resp();
}
inline const ::kvrpcpb::CmdRawDeleteResponse& Response::cmd_raw_delete_resp() const {
  // @@protoc_insertion_point(field_get:kvrpcpb.Response.cmd_raw_delete_resp)
  return cmd_raw_delete_resp_ != NULL ? *cmd_raw_delete_resp_ : *default_instance_->cmd_raw_delete_resp_;
}
inline ::kvrpcpb::CmdRawDeleteResponse* Response::mutable_cmd_raw_delete_resp() {
  set_has_cmd_raw_delete_resp();
  if (cmd_raw_delete_resp_ == NULL) cmd_raw_delete_resp_ = new ::kvrpcpb::CmdRawDeleteResponse;
  // @@protoc_insertion_point(field_mutable:kvrpcpb.Response.cmd_raw_delete_resp)
  return cmd_raw_delete_resp_;
}
inline ::kvrpcpb::CmdRawDeleteResponse* Response::release_cmd_raw_delete_resp() {
  clear_has_cmd_raw_delete_resp();
  ::kvrpcpb::CmdRawDeleteResponse* temp = cmd_raw_delete_resp_;
  cmd_raw_delete_resp_ = NULL;
  return temp;
}
inline void Response::set_allocated_cmd_raw_delete_resp(::kvrpcpb::CmdRawDeleteResponse* cmd_raw_delete_resp) {
  delete cmd_raw_delete_resp_;
  cmd_raw_delete_resp_ = cmd_raw_delete_resp;
  if (cmd_raw_delete_resp) {
    set_has_cmd_raw_delete_resp();
  } else {
    clear_has_cmd_raw_delete_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:kvrpcpb.Response.cmd_raw_delete_resp)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace kvrpcpb

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::kvrpcpb::MessageType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::MessageType>() {
  return ::kvrpcpb::MessageType_descriptor();
}
template <> struct is_proto_enum< ::kvrpcpb::Op> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::kvrpcpb::Op>() {
  return ::kvrpcpb::Op_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kvrpcpb_2eproto__INCLUDED
